
\chapter{Introduction}
\label{chap:introduction}

% The common way to make a computer program is to 'translate' (compile) the code
% written in some symbolic language to machine instructions using a compiler. The
% machine instructions are binary code, which is designed to work for a specific
% hardware platform, thus not portable. A newer approach is to compile into {\it
% virtual machine instruction set}, e.g. Java-Virtual Machine, then the
% interpreter executes the code on any hardware platform.

\section{BCPL to C}
\label{sec:BCPL_C}

BCPL (Basic Combined Programming Language) is a typeless programming languaged
developed in 1966 (by Martin Richards while he was visiting MIT). It's the
successor to the CPL programming language [{\it CPL was intended for a wider
area of application than scientific applications; but the language never gain much
popularity and disappeared in 1970s}]. BCPL is much simpler than CPL, and was
intended primarily for system programming, e.g.
writing compilers.

B programming language was mostly the work of Ken Thompson, and was heavily
influenced by BCPL. Early computers have very limited memory (e.g. 4K words of
RAM). Thus, B was designed to fit into the memory capacity of minicomputers of
the time. B has only 1 data type: {\it computer word} (or cell), which can be
treated as integers, or memory address (to be dereferenced). B introduced
generalized assignment (compound assignment) operators \verb!=op!. However, it
was fixed in 1976 to become \verb!op=!. Example:
\begin{verbatim}
x =+ y
\end{verbatim}
to add $y$ to $x$. This was fixed in 1976 becoming
\begin{verbatim}
x += y
\end{verbatim}
The reason is to avoid semantically error in the cases like x=-10, which need to
be written as x =- 10 (with explicit spaces before and after) to mean x=x-10,
rather than x get the value -10.

The B compiler on PDP-7 didn't generate the machine instructions, but the
'threaded code'. [{\it NOTE: The machine code is fast but is not portable, as
it's designed for a specific hardware platform. A different approach is virtual
machine instruction set where an interpreter executes it on each new hardware}].
Auto-increment was introduced as Thompson observed that the translation of
\verb!++x! was smaller that of \verb!x=x+1!.

\begin{mdframed}
PDP-7 was produced by DEC company, the third 18-bit computer (with essentially
the same instruction set with PDP-4 and PDP-9). The standard memory is 4KB
word, i.e. 9kB, with expandable to 64K words (144kB). The first UNIX system was
written on a PDP-7 using assembly language by Ken Thompson.
\end{mdframed}

To allow binary code using more than 8 kB, Thompson suggested paging the code
and data within the interpreter, but it was too slow to be practical for common
utilities around that time.

B and BCPL run fine on older computers (e.g. Honeywell, PDP-7). Like BCPL, B is
typeless too. However, its character-handling mechanism was clumsy (i.e. spread
packed string into individual 'cell' and then repack; or to access and replace
individual characters is not easy) on newer computer (e.g. PDP-11). Also, with
the increasing demand for using floating-point arithmetic, a single-word is not
enough to contain a floating-point number (on 16-bit PDP-11). Finally, the
definition of {\it a pointer}, as an index in an array of words, forced the
pointer to be represented as word indices (i.e. we cannot get access to byte
index). So, a typing scheme is necessary to deal with characters and byte
addressing, and to prepare for the coming floating-point hardware [NOTE:
floating-point unit was not available on computer around this time; only
interger arithmetic can be done].

In 1971, Dennis Ritchie made changes to the language, by adding data types to
the language, called ``New B''. Later on, with more features, it becomes a
completely new language, called C programming language. C programming language
is a typed language, and came out during the early development of UNIX operating
system (in early 1970s), as a combination of BCPL and B. The year 1970 is thus
called the Epoch year, from which date time calculation are referenced to
(Chap.\ref{chap:date-time}).

As C language was designed for compiler-writers, many concepts are chosen to
make it esier for compiler-writers, not for software developers. Example:
\begin{enumerate}
  \item index starting at zero: it likes offset to the address pointed by a
  pointer.
  \item data types are simple, directly supported by the hardware, i.e. no
  complex data type like in Fortran.
  \item array names are treated as pointers, not as a composite object. Even
  though array name and pointers are NOT always equivalent. (see later)
\end{enumerate}

\subsection{int, char}

The early C (or 'New B') has 2 types: {\it int}, {\it char}, arrays of them, and
pointer to them.
\begin{lstlisting}
int i, j;
char c, d;
int iarray[10];
int ipointer[];
char carray[10];
char cpointer[];
\end{lstlisting}
NOTE: \textcolor{blue}{In C, an array is indeed a pointer pointing to the first
element in the array}. Understanding the concept of pointer and how to use that
properly is very important in being a skilled C programmer.

\begin{enumerate}
  \item a declaration of an array with a given size (i.e. iarray, carray): the
  compiler allocate the chunk of memory, and the variable is indeed the pointer to the fist element of
  the array.
  \item a declaration of an array without the size (e.g. ipointer, cpointer) is
  a pointer: no storage should be allocated automatically. The compiler expect
  programmer to assign a referent to the pointer.
\end{enumerate}
So array subscripting and pointer arithmetic now depend on the type of the array
pointer. So to jump to the $i$-th element in the array, we can do either
\begin{lstlisting}
iarray[i]
\end{lstlisting}
or
\begin{lstlisting}
ipointer = iarray;
ipointer+i   /* jump i-times the size of the object referred to */
\end{lstlisting}


\subsection{pointers}
\label{sec:c_pointer}

Pointers are very important in C. By default: the asterisk (*) bind to the
keyword preceeding. Depending on the type of data a pointer is pointing to, we
call it \verb!int pointer!, \verb!char pointer!, etc.


So, \verb!int *i[5]! or \verb!int* i[5]! means $i$ is an array of five
int pointers, i.e. each pointer pointing to a memory location of type
\verb!int!.  An \verb!int! pointer is the pointer pointing to an integer.

\begin{mdframed}
Don't be affraid. \textcolor{red}{NOTE: If we use parantheses, we read from the
inner most to outside.}
\end{mdframed}

Example:
\begin{lstlisting}
    int i, *pi, **ppi;
\end{lstlisting}
declare an integer, an \verb!int! pointer, an \verb!int*! pointer (i.e. a
pointer to an \verb!int! pointer). When being used in the expression, they all
yield \verb!int! type.

Example: function pointer vs. normal function
\begin{lstlisting}
int f(), *f(), (*f)();
\end{lstlisting}
declare a function returning an integer, a function returning a pointer to an
integer, a pointer to a function returning an integer; 

Example: array of pointer vs. pointer to an array (Sect.\ref{sec:pointer-to-an-array})
\begin{verbatim}
int* arr[8]; // An (allocated) array of 8 elements, 
             // each element is a pointer to 'int'

int (*arr)[8]; // A pointer (no allocation) to an array of 8 integers

int *api[10], (*pai)[10];
\end{verbatim}
declare an array of pointers to integers, and a pointer to an array of integers.

Example:
\begin{verbatim}
int *(*pfp)();
\end{verbatim}
declare a pointer to a function returning a pointer to an integer. 

Using {\it boustrophedonically}, or Right-Left Thingy, i.e. start from the
variable then (if not blocked by the parentheses) read to right, and then left
\begin{verbatim}
int (*a[8])[5]; //a is an array of pointers to integer array of size 5

int (*arr2)[8]; // arr2 is a pointer to an array of 8 integer 
\end{verbatim}

\textcolor{blue}{RULE: When being used in an expression, the type is the one
named at the head of the declaration.} 

\url{http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation}

\subsection{structure (struct)}

To add structured (record) types, the rule is \textcolor{blue}{the values of the
array type, when they appear in expression, are convereted into pointers to the
first of the objects making up the array}.
\begin{lstlisting}
struct {
	int	inumber;
	char	name[14];
};
\end{lstlisting}

Read Sect.\ref{sec:struct}.

\subsection{$||$ and \&\&}

BCPL and B use bitwise operation (\verb!&! and \verb!|!). To test a masked value
against another value, we need to use [{\it DON'T FORGET the inner parantheses}]
\begin{verbatim}
if ((a&mask) == b) ...
\end{verbatim}

\subsection{unsigned, long, union, and {\it enum} types}

During 1973-1980, more types were added: \verb!long!, \verb!union!
(Sect.\ref{sec:union_C}), \verb!struct! (Sect.\ref{sec:struct-C}) and
\verb!enum! enumeration (Sect.\ref{sec:enum}) types. 

Also, \verb!struct! structure becomes the first-class object
(Sect.\ref{sec:struct-C++}). New specifier \verb!unsigned! was added to make
unsigned arithmetic available without confusing it with pointer manipulation. To
access a member of a structure, using pointer, we do
\begin{verbatim}
pointer->member
\end{verbatim}
It's a reference to a region of memory designated by the pointer, while the
member name specified only the offset and a type.

Also, to make the C code to be easily retarget to new hardware, Steve Johnson
developed a C compiler called \verb!pcc! (Portable C Compiler) in 1978. To
detect legal but suspicious constructions (e.g. functions uses), \verb!pcc! used
\verb!lint! to scan a set of files and remarked dubious constructions
(Sect.\ref{sec:lint}).

During 1980s, C language become popular with compilers available on every
machine architectures and operating systems. By 1985, there are many compilers
other than \verb!pcc!.

\subsection{Descendant of C language}

They are: Concurrent C [Gehani 89], Objective C [Cox 86], C* [Thinking 90], and
especially C++ [Stroustrup 86]. Other related ones are  Modula 3 [Nelson 91] and
Eiffel [Meyer 88].

\subsection{What make C popular?}

Doubtless the success of Unix itself was the most important factor. 

\section{Standardization: ANSI C vs. ISO C}
\label{sec:ANSI-C}

Even though C language was created in 1970s, its standard did not come out until
1989 (ANSI C) and 1990 (ISO C). Before this, the most popular book in C for
reference was {\it The C programming language} [Brian Kernighan \& Dennis
Ritchie](widely known as K\&R C book) (1978). The first version was more than 10
years before the first standard manual approved.

There are two standards of C: ANSI C and ISO C.
ANSI refers to something adopted by US; and ISO refers to things adopted by
Europe.

C language specification was standardized as C89 by ANSI X3J11 team; and then
standardized by ISO as C90. However, there is no technical difference between
C89 and C90 (Sect.\ref{sec:C89-C90}). ANSI C is the same as European standard
CEN 29899, and X/Open Standard. ANSI C is also adopted as Federal Information
Processing Standard, FIPS 160, issued by the National Institute of Standards and
Technology (NIST) in Mar-1991, and updated on Aug-1992.

C94/C95 (Sect.\ref{sec:C95}) is sometimes referred to as C89/C90 plus Normative
Addendum 1 (aka Amendment 1), whose main change is to add multibyte character
support for international character sets (Sect.\ref{sec:character_wide}).

The amendment 1 was officially added into the standard in C99 standard
(Sect.\ref{sec:C99}).

Nowadays, C language is maintained by ISO/IEC JTC1/SC22/WG14 working group.
Historically, ANSI C is referred to C89. However, nowadays, anything called ANSI
C is the same as ISO C. In fact C11 was adopted by INCITS as an ANSI standard
known as INCITS/ISO/IEC 9899-2012 which is the new ANSI C standard.

Even C++ came out since 1985, the first C++ standard was not published until
1998, with  C++ ISO/IEC 14882:1998, known as C++98.

%\subsection{Implementation of the standard C language specification}



\section{C89 or C90}
\label{sec:C89-C90}

In US, ANSI established X3J11 committee in the summer of 1983 to produce C
standard. The C standard was based on UNIX implementation, while the UNIX C
library is not portable to other operating system. As a result, this part is
removed from the standard. The new standard, ratified as ANSI X3.159-1989 was
the first ANSI document in 1989. This is known as ANSI C, Standard C, or
\textcolor{red}{C89}. 
In 1990, this ANSI C standard, with formatting changes, was adopted by ISO as
ISO/IEC 9899-1990, called C90. So, C89 or C90 are technically the same.
\footnote{\url{http://clc-wiki.net/wiki/C90}}

C89 lacks useful things like being able to declare variables at point of use,
designated initializers, and a bunch of other stuff.
 

C89/C90 has 32 keywords
\begin{verbatim}
auto     double     int     struct
break     else     long     switch
case     enum     register     typedef
char     extern     return     union
const     float     short     unsigned
continue     for     signed     void
default     goto     sizeof     volatile
do     if     static     while
\end{verbatim}
Among them, below are type specifiers, i.e. they precedes with a type name 
\begin{verbatim}
extern
volatile
const
\end{verbatim}
% It is important to use them in type definition, not type declaration
% (Sect.\ref{sec:declaration_definition}).  

To check the proper header files to use, see Sect.\ref{sec:C-standard-library}.


%X3J11 also introduced type qualifiers: \verb!const! and \verb!volatile!.

\subsection{<assert.h>}
\label{sec:C89_assert}
\label{sec:assert_C}

Using \verb!assert(logical expression)! is one way to help programmers checking
if something goes wrong, e.g. finding bugs.

C89 has \verb!<assert.h>! which define a macro name \verb!assert(...)!
that tests if a given 'expression' is true:

\begin{lstlisting}
#include <assert.h>
assert(logical expression);
\end{lstlisting}

\begin{enumerate}

  \item  if it's FALSE, then the calling process is terminated, and a diagnostic
  message is written to \verb!stderr!, with \verb!abort(3)! function is called
  (to effectively terminate the program).  The diagnostic message includes the
  text of the argument, the name of the source file, the source file line
  number, and the name of the enclosing function; the latter are, respectively,
  the values of the preprocessing macros \verb!__FILE__! and \verb!__LINE__! and
  of the identifier \verb!__func__!.   

Example:
\begin{verbatim}
program: program.c:5: main: Assertion `a != 1' failed.
Abort (core dumped)
\end{verbatim}
  \item if it's TRUE: does nothing
\end{enumerate}

The standard C \verb!assert! macro is disabled when the macro NDEBUG is
defined, meaning 'not debug'. Because it is a macro, with \verb!NDEBUG! defined,
\verb!assert! becomes
\begin{verbatim}
#define assert(ignore)((void) 0)
\end{verbatim}


TIPS: assert() is only used for testing; it should be disable for production
runs.  Example: So, we put NDEBUG in the begining of the file, 
\begin{verbatim}
#define NDEBUG

#include <assert.h>
\end{verbatim}
or we can pass it to the compiling option as -DNDEBUG.

\subsection{assignment}
\label{sec:assignment-in-C}

Important:
\begin{enumerate}
  \item  An assignment can't happen at file-scope outside all function
  definitions. 

Example: error
\begin{verbatim}
## file1.h
int a = b; //not acceptable

void abc()
{

}
\end{verbatim}

  
  \item In this standard, assignment is supported for objects of \verb!struct!
  data type as well.

  \item By default, \verb!int! type is assumed.

If we do something
\begin{lstlisting}
strategy = IMMEDIATE;
\end{lstlisting}
the compiler will do the best out of the error and assume it as
\begin{verbatim}
int strategy = IMMEDIATE;
\end{verbatim}
to print out the proper error message.

  \item Compound assignment (\verb!op=!): 
  
E.g.: \verb!a -= b! (which means a=a-b)
\end{enumerate}


%Several years after K\&R C book, assignment for 

\subsection{comments}
\label{sec:comment_C89}

In C89 or C90, only one type of comment is accepted. It supports multi-line
comment.  

A comment is anything between /* and */. It can be used for multi-line comments.
\begin{lstlisting}
int a= 10; /* start comment
    continue comment
    end comment */
\end{lstlisting}

\subsection{'const' type qualifier}
\label{sec:const_C}

Similar to \verb!volatile! (Sect.\ref{sec:volatile_C}), \verb!const! is a type
qualifier. However, they can also appear in the declarators (i.e. after
\verb!*! operator - see below). Both was added to C in C89.

NOTE: Based on the precedence rule, \verb!const! applies the constraint to the
first keyword on the left side; or if no keyword on the left side then it
applies to the keyword on the right side.

\begin{verbatim}
const int a = 5;
 
  // TIPS: initialize a constant based on some expression
const int x = (a<b) ? b : a;
\end{verbatim}

Example: for pointer, we don't need to initialize the data.
\begin{verbatim}
const void * vectorTable[];
void const * vectorTable[];  // the same
\end{verbatim}
\verb!const! applies to \verb!void!, not to the declarator-id
\verb!vectorTable!. Here, \verb!vectorTable! is an array whose elements are
pointers pointing to \verb!const void!. 


Where to use?
\begin{itemize}
  \item it can be applied to any data type, including the member of a structure
  or union
  \item if it is declared with an aggregate type, all members of the aggregate
  type are treated as having \verb!const! qualifier
  \item it can be used with \verb!volatile! qualifier (Sect.\ref{sec:volatile_C})
\end{itemize}

Using \verb!const! with a pointer ptr
\begin{verbatim}
int * ptr;
  ptr                      val1
---------             ------------
| val1   |      -->  |  var_2     |
---------            ------------
                      *ptr
                      &var_2
\end{verbatim}
The value of \verb!ptr!, i.e. val1, refers to the address of another memory
location. We can get the value storing in the memory location pointed by ptr
using \verb!*! operator, and we can get the address of the memory location for
the variable val2 using \verb!&! operator.


The question is can we fix (1) value of ptr, (2) value of the memory location
with the address given in ptr, (3) both the value of ptr and the value in the
memory location with the address given in ptr. 
% With (1), we can change the value of the pointer ptr, yet we cannot change the
% value of the memory location pointed by ptr.
\begin{verbatim}
Example:
  int i = 10;
  int j = 20;
  
// (1)
const int * ptr;
int const * ptr;
    ptr = &i ; // okay
    *ptr = 1 ; // error 

// (2)
int * const ptr; /// NOT valid, as we need the address from the beginning
int * const ptr = &i;  // okay
    *ptr = 1; // okay
     ptr = &j; // error
     
// (3)
const int * const ptr;
int const * const ptr;
\end{verbatim}


% A \verb!const! variable means that the memory address for that variable is
% fixed. However, the content of the memory address can be changed. So, you can
% assign to a \verb!const! variable. A \verb!const! variable can be left
% un-initialized.
\begin{verbatim}
int main()
{

const int x; /* uninitialized const compiles in C but fails in C++*/
   
const int x = 44;   /*  const qualification of int type  --
                        the value of x cannot be modified  */
const int *z;       /*  Pointer to a constant integer    --
                        The value in the location pointed
                        to by z cannot be modified         */
int * const ptr;    /*  A constant pointer -- a pointer
                        which will always point to the
                        same location                      */
const int *const p; /*  A constant pointer to a constant
                        integer -- neither the pointer or
                        the integer can be modified        */
const const int y;  /*  Illegal - redundant use of const   */   
}
\end{verbatim}

To see the difference of using \verb!const! between C and C++, read
Sect.\ref{sec:const_C++}.

\begin{mdframed}
TIPS: Be careful when using \verb!const! and \verb!volatile! with \verb!typedef!

Here is when the unexpected error occur
\begin{verbatim}
typedef void* VP;

const VP vectorTable[];
   // you may expect the same as
VP const vectorTable[];

   // However, this is what the second one turns out
void * const vectorTable[];
   // while the first one is interpreted as
const void * vectorTable[];      
\end{verbatim}

\textcolor{red}{RULE OF THUMB}: put \verb!const! and \verb!volatile! to the
left-most always.
\end{mdframed}

Example:
\begin{verbatim}
const struct employee {
    char *name;
    int   birthdate; /* name, birthdate, job_code, and salary are */
    int   job_code;  /* treated as though declared with const.    */
    float salary;
    } a, b;          /* All members of a and b are const-qualified*/
struct employee2 {
    char *name;
    const int birthdate;  /*  Only this member is qualified    */
    int job_code;
    float salary;
    } c, d;
\end{verbatim}

\subsection{data types}
\label{sec:C89_datatypes}

Data types in C can be basic types or aggregate types.
\begin{itemize}
  \item  The basic data type in C (\verb!char!, \verb!int!, \verb!float!, \verb!double!),
with optional specifiers (\verb!signed!, \verb!unsigned!, \verb!short!,
\verb!long!).

  \item The aggregate types are user-defined types that combine one basic types
  and/or other aggregate types, using \verb!struct!, \verb!union! keywords.

\end{itemize}

NOTE: Historically, by default, \verb!int! is assumed when no other type is
used. So, \verb!unsigned! by itself is a shorthand for \verb!unsigned int!; and
\verb!signed! means \verb!signed int! (in Standard ANSI C).
\begin{verbatim}
unsigned var1;
\end{verbatim}
\begin{enumerate}
  \item \verb!char! = 1byte (the smallest addressible unit). If we use only
  \verb!char!, it can be signed or unsigned, depending on the implementation of
  the compiler. We can also explicitly tell it to be signed or unsigned.
  \item \verb!short! = \verb!short int! = 2byte (signed). We can also explicitly
  tell it to be signed or unsigned.
  
  \item \verb!int! = 4byte (signed). We can also explicitly tell it to be signed
  or unsigned.
  
  \item \verb!long! = \verb!long int! = 8byte (signed). We can also explicitly
  tell it to be signed or unsigned. 

  \item \verb!float! = single-precision floating-point (4byte)
  
  \item \verb!double! = double-precision floating-point (8-byte or 64-bit)
  
  \item \verb!long double! = extended precision floating-point (implementation
  depending on the compiler which represents the data to  either 80-bit
  (non-IEEE) or software-emulated 128-bit precision math(IEEE 754 quadruple
  precision floating-point)). \textcolor{red}{Not widely used until C99, as
  functions from STL (Sect.\ref{sec:C-standard-library}) don't support argument of this
  type}.
  A common technique to implement nearly quadruple precision is called double-double arithmetic.
  
  GNU C Compiler (GCC) represent it as 80-bit precision on x86 processors
  regardless of the physical storage (96 or 128-bits). Since GCC 4.3, quadruple precision
  is supported on x86 processors, using a non-standard type \verb!__float128!.
  So to use 80-bit precision, we use \verb!__float80!. They can be used in
  simple operations. Since GCC 4.6, a separate library, {\bf libquadmath}
  dedicated to quadruple precision maths was added.
  
  
  For literal constant of type \verb!__float80!, a suffix 'w' or 'W' is used.
  For literal constant of type \verb!__float1281!, a suffix 'q' or 'Q' is used.
  To use complex, we either use GCC4.6 with libquadmath library and type
  \verb!__complex128!, or define
  \begin{verbatim}
typedef _Complex float __attribute__((mode(TC))) _Complex128;
typedef _Complex float __attribute__((mode(XC))) _Complex80;
  \end{verbatim}
  
  Exception: Microsoft Visual C++ for x86 make it just like \verb!double!. Intel
  C++ compiler on Windows requires adding the compiler option
  \verb!/Qlong-double! switch.
  
\begin{mdframed}
HP-UX only support \verb!__float128!. Other architectures (i386, x86\_64, IA-64)
support both \verb!__float80! and \verb!__float128!.
\end{mdframed}  
\end{enumerate}

{\bf Boolean}: C89 doesn't have a boolean type. Instead, a macro is defined.
Option 1: 
\begin{lstlisting}
typedef int bool;
#define true 1
#define false 0
#define TRUE 1
#define FALSE 0
\end{lstlisting}
Option 2:
\begin{lstlisting}
typedef int bool;
enum { false, true };
\end{lstlisting}
Option 3:
\begin{lstlisting}
typedef enum { false, true } bool;

typedef enum {
    false = 0,
    true
} t_bool;
\end{lstlisting}
NOTE: Options 2 and 3 don't use \verb!define!, which is considered better.
Boolean arguments should be avoided.

Comparing boolean value in C89 may be tricky (as in C, 0 for false, and non-zero
for true) [\textcolor{blue}{In C++, everything which is not 0 or a null pointer
value is converted to true}]. To avoid unexpected error, many people use only
\verb!int!, without any typedef or special defines or enum for true/false values
(as described above). A recommended coding style
\begin{lstlisting}
if (ready) ...
while (!empty) ...
\end{lstlisting}
NOT USING 
\begin{lstlisting}
if (ready == TRUE) ...
while (empty == FALSE) ...
\end{lstlisting}
 
\begin{mdframed}
COMMON MISTAKE: \textcolor{red}{!false is not guaranteed to equal +1 on all
systems}. !0 will in fact always be 1, but the point is that zero is the only
false value while all non-zero values are true. Example:
\begin{lstlisting}
#define TRUE  1
#define FALSE 0

char bValue = TRUE;
\end{lstlisting}
if \verb!char! is signed, then !FALSE evaluates to all 1 bits, which is
interpreted as -1, which is not equal to your original definition of TRUE as 1.
\end{mdframed}

A programmer can also define new types using keywords \verb!struct!,
\verb!union!, and \verb!enum!.
\begin{enumerate}
  \item \verb!struct!: to define record-based structure, the size of the data
  object is the sum of all structure's element.
  
  \item \verb!union! (Sect.\ref{sec:union_C}): all data members start from the
  same address, the size of the object is the size of the member of largest
  size. We typically use \verb!union! in the case you only want to use of of the
  data element at a time
  \begin{lstlisting}
union foo {
  int a;   // can't use both a and b at once
  char b;
} foo;
  \end{lstlisting} 
then for each variable of type \verb!union foo!; only one data member can be
used.
\begin{verbatim}
union foo x, y;

x.a = 4;
y.b = 5; //OKAY

x.b = 5; //will affect the value of x.a
\end{verbatim}
    
  \item \verb!enum!: C language allows you to define a subset of integer values
  using a user-defined type name. This is useful in many cases
\begin{lstlisting}
typedef enum {RANDOM, IMMEDIATE, SEARCH} strategy_t;

strategy_t my_strategy = IMMEDIATE;
\end{lstlisting}
\textcolor{blue}{RECOMMENDATION}: Add \verb!_t! suffix after the variable to
means it's a type. The use below create a single instance variable, called
'strategy' of a nameless enum
\begin{lstlisting}
enum {RANDOM, IMMEDIATE, SEARCH} strategy;
\end{lstlisting}
We don't need to use \verb!typedef!, and reuse this to define
variable (however, it's not a good programming style)
\begin{lstlisting}
enum strategy my_strategy = IMMEDIATE;
\end{lstlisting}

  
\end{enumerate}


\subsection{'extern'}
\label{sec:extern_C}

There are two stages to define an identifier (a variable or a function):
declaration and definition (Sect.\ref{sec:declaration_definition}).
Only the stage 'definition', that the memory for the identifier is created.
To tell the compiler that you don't want to create the memory for an identifier, 
we put \verb!extern! keyword in the front. This explains why we use it.

In C language, there are multiple scopes (Sect.\ref{sec:scopes_in_C}).
There is the case that you have a global variable that is defined in file1.c,
and you want to use it in file file2.c. When you compile multiple source codes,
you need to compile the file individually (in pair .c/.h) into object files, and
then you link them together using linkage tools. So, when you compile file2.c,
to tell the compiler that this variable has already be defined some where, don't
create a memory for it, it references to some memory defined in another file
(which to be linked in the linkage stage). Here, we need to use \verb!extern!
keyword.

In short: \verb!extern! is used to extend the visibility of a C variable or a C
function.
\begin{verbatim}
//file1.h
#include "file2.h"
extern int global_variable;  /* Declaration of the variable */

// file1.c
#include "file1.h"

// file2.h  
int global_variable;  /* Definition of the variable */

// file2.c
#include "file2.h"
\end{verbatim}

\textcolor{red}{\bf TIPS}: If we want to use a global variable in multiple files, we can avoid
using 'extern' in every file that uses the variable, 
by putting the declaration as 'extern' in a single header file
\begin{verbatim}
//global_vars.h
extern int global_variable;  /* Declaration of the variable */

//global_vars.cpp
int global_variable=4;

//file1.cpp
#include global_vars.h
/*
	use global_variables
*/

//file3.cpp
#include global_vars.h
/*
	use global_variables
*/

\end{verbatim}
which can be included by other files
\begin{verbatim}
#include "file3.h"
#include <stdio.h>

void use_it(void)
{
    printf("Global variable: %d\n", global_variable++);
}
\end{verbatim}
and here is the source where we really define the global variable.
\begin{verbatim}
#include "file3.h"  /* Declaration made available here */

/* Variable defined here */
int global_variable = 37;    /* Definition checked against declaration */

int increment(void) { return global_variable++; }
\end{verbatim}

\textcolor{red}{\bf REMINDER}: By default, in GCC, \verb!extern! is automatically added to
every C function declaration, i.e.
\begin{lstlisting}
int my_foo(int a, double b);

int do_it (int c) {
    int x = my_foo(1,3.0);
}
\end{lstlisting}
becomes
\begin{lstlisting}
extern int my_foo(int a, double b);

int do_it (int c) {
    int x = my_foo(1,3.0);
}
\end{lstlisting}

\textcolor{red}{\bf TRICKS}: Assignment at declaration with a non-zero value is
an error. In the case of C variable, the below statement is
declaration+definition, i.e.
the compiler understands that \verb!my_var! is of type \verb!int! and allocates
4 bytes for \verb!my_var!
\begin{lstlisting}
int my_var;
\end{lstlisting} 
However, if \verb!my_var! is defined somewhere else, and we only want to tell
the compiler that it can use this variable of type \verb!int!, we need to
explicitly add 'extern' to the code
\begin{lstlisting}
extern int my_var;
\end{lstlisting}
Here, no memory allocation has been done. So, there's no problem to use (as
zero is the default initialization value at declaration time)
\begin{verbatim}
extern int my_var=0;
\end{verbatim}
However, assigning a non-zero value like below gives error (as it tries to
redefine the default value at declaration time)
\begin{verbatim}
extern int my_var = 1;
\end{verbatim}

\textcolor{red}{TRICKS: call C++ from C}: Name mangling is a technique the
compiler use to rename an identifier, to avoid name clash
(Sect.\ref{sec:name_mangling}). As a result, a C++ identifier, once compiled, at
the code-level, does not have the same name as in the code, and thus it makes it
impossible to call it from a C code. So, if you want to code to be callable
from both C and C++, to resoslve the above issue, we use \verb!extern ``C''!,
and put inside
\begin{verbatim}
#ifdef __cplusplus 
\end{verbatim}
to tell that a variable/function has a C linkage, to suppress C++
name mangling, which enable a C++ function to be called from C, or vice versa
(see Sect.\ref{sec:C++-callable-from}).

SUMMARY: 
\begin{itemize}
  \item an \verb!extern! variable, i.e. just declaration and the variable
  already defined elsewhere
  \item an \verb!extern! function definition, i.e. the function has global scope
\end{itemize}

References:
\url{http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/}

\subsection{I/O library}
\label{sec:C89_IO}

Standard I/O library: X3J11 also  defined a set of standard procedures, for
input-output or any other interactions with the outside world. In 1972, Mike
Lesk wrote the portable I/O package, which become C standard I/O routines.

\begin{lstlisting}
 printf("Color %s, number1 %d, number2 %05d, hex %#x, float %5.2f, unsigned value %u.\n",
        "red", 123456, 89, 255, 3.14159, 250);
\end{lstlisting}
\begin{enumerate}
  \item \verb!%s!: for \verb!char*! 
  \item \verb!%f! or \verb!%x.yf!: for floating-point (x.y=use x digits before
  decimal point; and y digits after decimal point)
  \item \verb!%u!: use with \verb!unsigned int! data types
  \item \verb!%d! or \verb!%0xd!: print decimal value (expected \verb!(signed)!
   \verb!int!) (0x= add 0
   until the length is  x-digit)
  \item \verb!%x!: print hexadecimal value, expect \verb!unsigned int!
\end{enumerate}  

\subsection{international character sets}

\subsection{locale}
\label{sec:C89_locale}

International locale allows a program to change the behavior according to the
user's language environment. It provides 3 components:
\begin{enumerate}
  \item programming tools to create language-specific data
  \item programming interfaces (functions)  to access to these data
  \item methods to create the program that are automatically sensitive to the
  language environment in which the program runs.
\end{enumerate}

For more information, read Sect.\ref{sec:locale}

\subsection{typedef: define type alias}
\label{sec:typedef}

% \verb!typedef! is a language construct that associates a keyword to a type to
% ease the reading of code. 
% \begin{verbatim}
% typedef   my_ver_long_data_type_name   my_short_type;
% \end{verbatim}
% Here, the keyword is at the end.

\verb!typedef! is a language construct that associates a keyword to a type to
ease the reading of code. 
\begin{verbatim}
typedef   my_ver_long_data_type_name   my_short_type;
\end{verbatim}
Here, the keyword is at the end. So, by using \verb!typedef!, we don't create a
new data type, it just create an aliases to an existing data type. 

{\bf typedef vs. \verb!#define! } (Sect.\ref{sec:define}): There are two
important differences to notice. (1) \verb!#define! is used to define an alias
to any thing. Thus, when the compiler see \verb!#define!, it does text
substitution, thus a macro name for a type can be extended
\begin{verbatim}
#define peach int;

unsigned peach i; /* work fines */
   // the compiler change to "unsigned int"


typedef peach int;
unsigned peach i; /* ILLEGAL */
\end{verbatim}
and (2) macro expansion applies to the first declarator only
\begin{verbatim}
#define int_ptr int*;

int_ptr a,b; // --> expect: a <- int*, b <- int*
         // REALITY: a <- int*, b <- int
         
typedef int* int_ptr;

int_ptr a,b;  // what we expect is what it becomes
        // REALITY: a <- int*, b <- int*;         
\end{verbatim}

USAGES of \verb!typedef!:
\begin{enumerate}
  \item  Be careful when using \verb!typedef! for pointer type
(Sect.\ref{sec:typedef_pointers}), which may lead to unexpected errors.
Reference to macros (Sect.\ref{sec:macro_C}).
   \item \verb!typedef! is often used to define the complex return type of a
   function (Sect.\ref{sec:function_pointer})
   
   \item \verb!typedef! for a struct
\end{enumerate}
   

IMPORTANT: Put one declarator for one \verb!typedef! only

\subsection{macros (pre-processors)}
\label{sec:macro_C}

The preprocessor performs macro substitution, using conventions distinct from
the rest of the language.

The preprocessor replace all macro calls directly within the macro code. In C++,
it is recommended to always use inline function instead of macro
(Sect.\ref{sec:inline_C++98}).
\begin{itemize}
  \item  Macro cannot access private members of class. 

\begin{lstlisting}
#include <iostream> 
using namespace std; 
class S 
{ 
    int m; 
public: 

#define MAC(S::m)    // error  [no access to private member]
};
\end{lstlisting}

  \item Macros looks like function call but they are actually not.

\end{itemize}

The syntax for parameter declarations was augmented to include the style used in
C++.

Pre-defined macros [NOTE: Predefined macros cannot be the subject of
\verb!#define! or \verb!#undef!]. An naming convention for ANSI/ISO standard
macros start with two underscore (\verb!__!) immediately preceding the name
which is in UPPER-case letter, and two underscore characters at the end.
\begin{itemize}
  \item \verb!__STDC__! macro is used to split code in Standard C and K\&R C
  section to prevent the use of feature available only in Standard C (this is
  due to many conflict between codes using original K\&R C vs. code written in
  Standardized C)
  \begin{verbatim}
  #if __STDC__
     //code conform to ANSI standard
  #else
  	 //non-standard code, e.g. CONHERENT C
  #end
  \end{verbatim}
  
  \item \verb!__DATE__! (date in the form ``Mmm dd yyyy'' that the source file
  is translated), \verb!__TIME__! (time in the form ``hh:mm:ss'' that the source
  file is translated), \verb!__FILE__! (name of current source file), and
  \verb!__LINE__! (current line in the current source file)
  \begin{verbatim}
#include <stddef.h>
#include <stdio.h>
main(void) {
   printf("Date: %s\n", __DATE__);
   printf("Time: %s\n", __TIME__);
   printf("File: %s\n", __FILE__);
   printf("Line No.: %d\n", __LINE__);
}
  \end{verbatim}
\end{itemize}

\subsection{'static' keyword}
\label{sec:static_C}

In C, \verb!static! keyword has different meanings depending where
it is declared. Most of us put \verb!static! at the beginning (the first
leftmost declaration specifier); however, it's just a common convention; not a
language requirement.

\begin{itemize}
  \item declared to a variable inside a function: its latest value is kept
  between invocations of that function. 

The \verb!static! variable local to a function reside on the {\bf static memory
space}, not the heap nor the stack. 
\begin{verbatim}
int foo()
{
   static int x;
   return ++x;
}
\end{verbatim}
It is often used as a counter, to see how many times the
function has been invoked. IMPORTANT: the code is not thread-safe and harder
to understand.
  
  \item declared to a variable/function at file scope: visible only in this
  file (Sect.\ref{sec:scopes_in_C}).

  \item declare with array dimension: to indicate non-NULL array (which can be
  useful for optimization)

Example: there should be at least 10 elements in the input array
\begin{Verbatim}
int someFunction(char arg[static 10])
{
    ...
}
\end{Verbatim}
  
NOTE:
\begin{Verbatim}
void someFunction(char someArray[const])
{
    // do something cool here
}
\end{Verbatim}

  
\end{itemize}

The meaning of \verb!static! in C++ is different 
(Sect.\ref{sec:OO_static-member}).


\subsection{'void'}

'void' means 'nothing', or 'no type'. There are three POPULAR ways to use
\verb!void!.
\begin{enumerate}
  \item A function that accept nothing (no argument), e.g. \verb!int!
  \verb!my_foo(void)!. In C++, 'void' in argument list is optional,
  i.e. \verb!int my_foo()!. In C, using \verb!my_foo()! means it can takes any
  number of parameters of any type.
  
  \item A void function (return nothing), e.g. \verb!void my_foo(int)!
  
To specify the return of a \verb!void! function, we use 
\begin{verbatim}
return; 

// or 
if (condition) return;
\end{verbatim}

  \item A generic data pointer (a pointer to data of unknown type), must be
  casted to a proper known data type when being used, e.g. \verb!void* data!
\end{enumerate}

Other two usages:
\begin{enumerate}
  \item Usage of value is absent, e.g. \verb!(void) p!
  \item Initialier is absent, e.g. \verb!T t=void;!
\end{enumerate}

References:
\url{http://stackoverflow.com/questions/1043034/what-does-void-mean-in-c-c-and-c}

\subsection{'volatile' type specifier}
\label{sec:volatile_C}

Like \verb!const! (C lang - Sect.\ref{sec:const_C}, C++ lang -
\ref{sec:const_C++}), \verb!volatile! is another type specifier, i.e. it applies
constraints to the type, not to the declarator-id. An object with
\verb!volatile! keyword at definition is called a volatile object.
The meaning between \verb!const! and \verb!volatile! are different, but using
syntax are the same, so it is suggested to read Sect.\ref{sec:const_C} first. 

\textcolor{red}{RULE OF THUMB}: put \verb!const! and \verb!volatile! to the
left-most always.

When to use? We define a variable as 'volatile' when we don't want the compiler
to apply any optimization on it. By default, when the compiler compile a code,
it may detect and determine whether to optimize the location of a variable,
and/or reorganize the code.

Example: if there is no statement to change the value of it, so optimiation rule
can be applied.
Example 1:
\begin{verbatim}
a = 1;
b = 4; 
a = 5;
\end{verbatim}
a clever compiler can become
\begin{verbatim}
a = 5;
b = 4;
\end{verbatim}
In some cases, you don't want the compiler to do these changes, e.g. you're
writing a device driver and you actually want to write those values (1 and 5) to
the memory-mapped I/O locations. The solution is
\begin{lstlisting}
volatile int a;
\end{lstlisting}

\textcolor{red}{The compiler always allocate the memory for the volatile
object on RAM (not registers, cache); thus allowing the object to be accessible
from any where, and thus is vulnerable to side effects.}

Example 2:
\begin{lstlisting}
static int foo;
 
void bar(void) {
    foo = 0;
 
    while (foo != 255)
         ;
}
\end{lstlisting}
will be compiled as
\begin{lstlisting}
void bar_optimized(void) {
    foo = 0;
 
    while (true)
         ;
}
\end{lstlisting}
However, if \verb!foo! is the variable that might represent a location that can
be changed by some other elements of the computer system, e.g.
other process/threads, we don't want optimization rule to be applied on this
variable so that {\it every read from or write to this variable remains in the
code, in the order in which it was written}, then we define the variable as
\verb!volatile!.
\begin{lstlisting}
static volatile int foo;
\end{lstlisting}


\textcolor{red}{IMPORTANT}: The use of 'volatile' as a portable synchronization
mechanism is NOT recommended, i.e. using a variable on global RAM that can be
accessed by different threads/processes.
\begin{itemize}

  \item  Since C++11, memory barrier operations should be preferred (guarantee
  correct behavior in multi-threaded scenarios, and compiler can do better
  optimization) - Sect.\ref{sec:memory_fences}

\end{itemize}

Combining \verb!const! and \verb!volatile! qualifiers is useful, for example, in
a declaration of a data object that is immutable by the source process but can
be changed by other processes, or as a model of a memory-mapped input port such
as a real-time clock.

\subsection{variadic function}
\label{sec:variadic_function}

Variadic functions are functions that can be used with different number of
arguments, i.. with variable argument list. It is a form of overloaded function
(Sect.\ref{sec:overloaded-function}) that is used in C. In C++, since C++11, we should use 
Parameter pack (Sect.\ref{sec:parameter-pack}).

An example if the \verb!printf! function {\small
\begin{verbatim}
printf("Color %s, number1 %d, number2 %05d, hex %#x, 
         float %5.2f, unsigned value %u.\n",
        "red", 123456, 89, 255, 3.14159, 250);
        
printf(``Color %s'', ``blue'')        
\end{verbatim}
}

To define a variadic function, we need to use \verb!<stdarg.h>! header file
which define necessary macros to interperet the argument list, and passing
\verb!...!  (three dots) at the end of the function definition/declaration.
\textcolor{red}{Before you read further, remember that since C++11, a
standardized way - variadic templates - is used}
(Sect.\ref{sec:variadic-template}).

\begin{mdframed}

NOTE: \verb!<varargs.h>! was used before the standardization of C language, which is
not part of the ISO nor POSIX. Nowadays, using \verb!<varargs.h>! should be avoided. 

\end{mdframed}

\begin{enumerate}
  
  \item a function is defined with fixed parameters at the beginning, and then use three dots at the end of argument list 
  to represent variable argument list.
  
   The tripple dots is a special token which marks the function as variadic,
   meaning that call sites can pass an arbitrary list of values following the
   named parameters.
   
  \item accessing to the variable argument list, we need to use some pre-defined macros:
\verb!va_list!, \verb!va_start! and \verb!va_end! (defined in header file \verb!stdarg.h!).
  
  First define a variable of type \verb!va_list!; this variable will tracks the variable argument list.
  It’s effectively a pointer to an arguments in the var-args array.
  
  Then, define an iterator to iterator through this list using \verb!va_start!
  (first argument is the \verb!va_list! object above, the second argument is the name of the last
  fixed parameter).
  After calling \verb!va_start!, argp points at the first var-argument.
  
  Extract the argument using \verb!va_arg!. You call it with a \verb!va_list!
  and a \verb!type! of the expected argument, and it takes value pointed at by
  the \verb!va_list! as a value of the given type, then increment the pointer by the
  size of that pointer.
\begin{verbatim}
va_arg(argp, int) will return (int) *argp, and increment the pointer, so argp += sizeof int
\end{verbatim}


  \item How do we know when we reach the end of the var-arguments array? Simple:
  we don’t! Or rather, this API doesn’t tell us, so we have to know in some
  other way.
  
  Example: In the case of printf, it assumes there are at least as many
  var-arguments as there are format specifications (e.g. \%s) in the format
  string.
  
  \item At the point that we’ve stopped consuming arguments, we must call
  \verb!va_end(argp)!. This does nothing in GNU C Lib, but the ISO C standard requires
  us to call it.
  
\end{enumerate}
\url{https://jameshfisher.com/2016/11/23/c-varargs/}
\footnote{\url{http://www.cprogramming.com/tutorial/c/lesson17.html}} 

Example: find the sum of elements
{\small \begin{verbatim}  
#include <stdio.h>
#include <stdarg.h>

int add(int x, int y, ...){

  va_list intargs;
  int temp = 0;

  va_start(intargs, y);
  int i; //assume 4 additional arguments
  for (i = 0; i < 3; i++){ /* how to loop through any num of args? */ 
        temp += va_arg(intargs, int);
  }
  va_end(intargs);

  return temp+x+y;
} 

int main(){
  printf("The total is %d.\n", add(1, 2, 3, 4, 5));
return 0;
}
\end{verbatim}}

\begin{itemize}
  \item \verb!va_list ap!: define a variable of type \verb!va_list! to store the
  variable-length argument list. This must be called first before checking
  variadic arguments.
  \item \verb!va_start(ap,n)!: read all the arguments passed to the function
  into \verb!ap!, given 'n' as the argument that directly precedes the ellipsis
  (\ldots).
  
  Then, to loop through the argument following 'n', we need a loop. The next
  argument, with a given \verb!type! is retrieved using \verb!va_arg()!
  
  \item \verb!va_arg(ap, data-type)!: return the next argument in the list, the
  second argument tells the type of that argument, which can be anything that
  you think it matches the argument.
  \begin{verbatim}
void ** ptr;
ptr = va_arg(ap, void**);
\end{verbatim}
 IMPORTANT: \verb!va_arg()! CANNOT determine the actual type of the argument
 passed to the function, but use the information you pass to it. Also, it cannot
 determine whether the retrieved argument is the last one passed to the
 function or if the element past the end of the list. So, there must be some
 mechanism to detect the last element (as mentioned above).

  \item \verb!va_end(ap)!: to clean up the list (IMPORTANT: must call this )
\end{itemize}

IMPORTANT: It cannot detect the data type of the arguments. Thus, it's
important that the function must know in advance the data type of these
arguments. As user can pass any number of arguments, the question is how to know
how many arguments is being used?
\begin{enumerate}
  \item Use NULL as the large argument
  \item Use one of the argument and passing to it the number of arguments being
  used.
\end{enumerate}

OPTION 1: a sentinel value (e.g. NULL or -1) as the terminator must
be used as the last argument. The problem with the NULL at the end is at some
point someone will forget it and it may become a hard to debug bug.
\begin{verbatim}
print_nt_strings ("herp", "derp", "hurr", "durr", NULL));

static void print_nt_strings(const char *s, ...)
{
	va_list v;
	va_start(v, s);
	
	/* Stop on NULL */
	while (s)
	{
		printf("%s", s);
		
		/* Grab next parameter */
		s = va_arg(v, const char *);
	}
	
	va_end(v);
}
\end{verbatim}
Variable argument functions, such as \verb!printf! need some sort of indication
as to how many items are passed in: \verb!printf! itself uses the format string
up front to figure this out. 

OPTION 2: use an argument to pass the number of real argument
Example:
{\small \begin{verbatim}
#include <stdarg.h>
 
//the first argument tells the number of arguments after it
int summate(int n, ...)
{
    va_list ap;
    int i = 0;
 
    va_start(ap, n);
    for (; n; n--)
        i += va_arg(ap, int);
    va_end(ap);
    return i;
}
\end{verbatim} }

\begin{mdframed}
If you see code using <varargs.h>, the code must follow old-style C function
definition (Sect.\ref{sec:using_function_C89}).
\end{mdframed}

Example: you can also write the above function using this form 
{\small \begin{verbatim}
#include <varargs.h>
 
summate(n, va_alist)
    va_dcl /* no semicolon here! */
{
    va_list ap;
    int i = 0;
 
    va_start(ap);
    for (; n; n--)
        i += va_arg(ap, int);
    va_end(ap);
    return i;
}
\end{verbatim}}


\subsection{Using function}
\label{sec:using_function_C89}

\textcolor{red}{How to define a function}: There are an old-style C and
new-style C
\begin{enumerate}
  \item Old-style: where the argyment's type is defined later
  \begin{verbatim}
  #include <stdarg.h>
 
int summate(n, ...)
    int n;
{
    /* ... */
}
  \end{verbatim} 
  \item New-style: where the argument's type is defined on the same line with
  the argument name.
  \begin{verbatim}
  #include <stdarg.h>
 
int summate(int n, ...)
{
    va_list ap;
    int i = 0;
 
    va_start(ap, n);
    for (; n; n--)
        i += va_arg(ap, int);
    va_end(ap);
    return i;
}
  \end{verbatim}
\end{enumerate}

As mentioned in Sect.\ref{sec:extern_C}, a function has a declaration part and a
definition. The declaration part is also called the {\bf prototype} (function
interface). The definition is the function body. A function prototype (function
interface) omits the function body, but contains the information about
function's return type, names and argument types.

NOTE: A function definition is always a declaration, but not all declarations
are definitions. A function definition contains declarations and function body.
A function body is a section of code enclosed in braces (\{ and \}), aka curly
brackets to act as a single statement for control structures or to limit the
scope of declations.

In C, if you use a function that has not been declared, the compiler assumes it
returns an \verb!int! value; and no assumption about the arguments. So, it's
impossible to do compile-time checking of arguments, which can cause potential
problems (undefined behavior). If one uses a function that return a
non-\verb!int! value and uses it before the function definition, they need to be
declared before being used.

\textcolor{red}{How to declare a function}: example is the function
\verb!some_function()! is being used before the compiler reaches the function
definition. 
\begin{lstlisting}
long some_function();

/* int */ calling_function()
{
    long test1;
    register /* int */ test2;
 
    test1 = some_function();
    if (test1 > 0)
          test2 = 0;
    else
          test2 = other_function();
    return test2;
}


long some_function() {
   ... 
}

/* int */ other_function(){
  ...
}
\end{lstlisting}
REMEMBER to always add the function prototype before the code that
uses it. One way to do this easily is to organize the code into header
files (.h, .hpp) and source file (.c, .cpp). Every time, we want to uses
functions written in another file, we just need to include the corresponding
header file.

The use of comment here means that it's not neccessary to add the returning type
if the function return an \verb!int! value. This is popular in K\&R C. If not
specify the returning type, by default, the function return an \verb!int! value
() [\textcolor{red}{OBSOLETE FEATURE in NEWER VERSION of C}].
In newer version of C, an explicit returning type is required.

\begin{mdframed}
\verb!lint! utility was a popular tool to check for consistency of function use
across multiple source files.
\end{mdframed}

Several years after K\&R C book, functions now can 
\begin{enumerate}
  \item return \verb!struct! or \verb!union! types (rather than pointers)
\end{enumerate}

The major changes is that formal arguments in the type signature of a function
using syntax borrowed from C++, i.e. old-stype is
\begin{lstlisting}
double sin();
\end{lstlisting}
while the new one is
\begin{lstlisting}
double sin(double);
\end{lstlisting}

NOTE: Boolean arguments should be avoided
\begin{lstlisting}
void foo(bool option) { ... }
\end{lstlisting}
If you want to use, it's better to redefine some meaningful values
\begin{lstlisting}
typedef enum { OPT_ON, OPT_OFF } foo_option;
void foo(foo_option option);
\end{lstlisting}
or
\begin{lstlisting}
#define OPT_ON true
#define OPT_OFF false
void foo(bool option) { ... }
\end{lstlisting}
So, when calling the function, the below looks better
\begin{lstlisting}
foo(OPT_ON);
foo(OPT_OFF);
\end{lstlisting}
THAN
\begin{lstlisting}
foo(TRUE);
foo(FALSE);
\end{lstlisting}

\subsection{Using procedure}

Several years after K\&R C book, unoffical features were added. One of them is
\verb!void! function, i.e. a subroutine. C language doesn't differentiate
between functions and procedures. Conceptually, a precedure is a function whose
return type is \verb!void!.

\begin{lstlisting}
void my_procedure(int a, char * b);
\end{lstlisting}

\subsection{structural (loop/conditional) statements}

\begin{enumerate}
  \item if-else
  \item do-while
  \item while
  \item for
\end{enumerate}
\verb!break! to leave the inner most enclosing loop. \verb!continue! to
skip from here to the end of this iteration and continue to the next iteration.

Fast condition:
\begin{lstlisting}
result=condition?value_true:value_false
\end{lstlisting}
result will receive a value \verb!valu-true! if condition is true, or
\verb!value_false! otherwise.



\subsection{non-structural statement}
\label{sec:goto}

\verb!goto! statement can be used, but not recommended. It branches the
execution directly to the statement with the designated LABEL, within the
function. 

\verb!switch! select a \verb!case!.

\subsection{namespace}
\label{sec:namespace_C}

There are different namespaces in C
\begin{enumerate}
  \item label name 
  
  \item tags (one namespace for all structs, enums and unions), i.e. we cannot
  have two tags with the same name, even thoug one is used for \verb!enum! and
  the second one is used for \verb!union! tag.
  
  \item typedef'ed types
  
  \item struct and union's member names (each struct or union has its own
  namespace)
  
  \item everything else, e.g. normal variables or pointers
\end{enumerate}
\textcolor{red}{But C does not allow programmer to create new namespace}.

Example: the tag \verb!foo! of the struct and the type \verb!foo! of typedef are
in different namespace, so no name clashing. Similarly, the member name \verb!a!
in struct \verb!foo! and typedef'ed type \verb!foo! are in different namespace
too.
\begin{verbatim}
struct foo
{
    int a;
};

typedef struct bar
{
    int a;
} foo;
\end{verbatim}


Everything within a single namespace must be unique; but identical names is
allowed if they are from two different namespaces. If you read very old
compilers, this is not applied. Thus, unique intial is often used. Example is
the code from BSD 4.2 kernel
\begin{verbatim}
// a prefix 'v' is used
struct vnode {
   long          v_flag;
   long          v_usecount;
   struct vnode  *v_freef;
   struct vnodeops   *v_op;
}
\end{verbatim}


Example: this is legal, but confusing
\begin{verbatim}
// tag 'foo'
// data member 'foo'
// label name 'foo'
struct foo { int foo; } foo;

typedef struct foo2 { int foo2;} foo2;

struct foo var_1;
foo2       var_2;
\end{verbatim}

This is better
\begin{verbatim}
typedef struct foo_tag {int foo2;} foo_type;

struct foo_tag var_1;
foo_type       var_2;
\end{verbatim}

TIPS: to access names without writing out the namespace name every time, include
the relevant preprocessor macros in a header file,
\begin{verbatim}
#define myfunction mylib_myfunction
\end{verbatim}

\subsection{\#define}
\label{sec:define}

We compared \verb!#define! vs. \verb!typedef! in Sect.\ref{sec:typedef}. There
are situation \verb!#define! becomes very handy.

\begin{verbatim}
#define STRCMP(a,R,b)  (strcmp(a,b) R 0)

if ( STRCMP (s, ==, 'mystring') ) 
{
   // do something when the two strings are the same
}
\end{verbatim}

\section{C94/C95}
\label{sec:C95}

To correct some details and add more extensive support for international
character sets, some amendments were add, known as C94 or C95 or ISO/IEC
9899/AMD1:1995 (Sect.\ref{sec:MSE}).


\subsection{iso646.h}
\label{sec:iso646.h}

This header file contains many useful macros to replace mathematical operators
\begin{Verbatim}
and	&&
and_eq	&=
bitand	&
bitor	|
compl	~
not	!
not_eq	!=
or	||
or_eq	|=
xor	^
xor_eq	^=
\end{Verbatim}
For consistency, C++98 provide \verb!<ciso646>!; yet we don't need to use these
in C++ as the above identifiers are now part of the C++ language.

\section{C99}
\label{sec:C99}

The big leaps were between pre-ANSI and ANSI and then to C99. 

ISO released an extension to the standard in 1995, and a revised standard in
1999, known as C99. It introduced many new features.

To check if C99 is support, check the standard macro \verb!__STDC_VERSION__!
\begin{verbatim}
#if __STD_VERSION__ == 199901L
   write C99 code
#elif 
   write C89 code
#endif       
\end{verbatim}

Apart from 32 existing keywords, C99 added 5 new keywords
\begin{verbatim}
_Bool         _Complex      restrict
_Imaginary    inline 
\end{verbatim}
\verb!restrict! keyword is used in pointer declaration
(Sect.\ref{sec:pointer_restrict}).

Almost all C99 featuers have been suported in GCC 4.5. To use C99 features,
compile the code with \verb!-std=c99 -pedantic-errors!.
\url{https://gcc.gnu.org/c99status.html}



\subsection{assertion}
\label{sec:C99_assert}

Sect.\ref{sec:C89_assert} introduced assertion. In C99, the same
\verb!assert(expression)!, but more information is written out, i.e. 

References: \url{http://www.pixelbeat.org/programming/gcc/static_assert.html}

\subsection{Arrays}

C99 now supports  variable-length arrays (VLA) (Sect.\ref{sec:VLA}). 

\subsection{comments}

In addition to multi-line comment using /* and */, C99 now support one-line
comment using // (a feature from BCPL and C++).
\begin{lstlisting}
int c = 10; //This is a comment (until the end of line)

\end{lstlisting}

\subsection{(new) data types}

In addition to existing data type (Sect.\ref{sec:C89_datatypes}), C99 has 
\begin{enumerate}
  \item \verb!long long! = \verb!long long int! = 16byte (signed).  We can also explicitly
  tell it to be signed or unsigned.
  
  \item \verb!_Bool! boolean type (header: stdbool.h). PLAN: to make sure
  \verb!bool! become the intrinsic type, not \verb!_Bool!.
  
  \item 2 optional specifiers: \verb!_Complex! and \verb!_Imaginary! (header:
  complex.h) to modify \verb!float!, \verb!double! and \verb!long double! only.
  \begin{lstlisting}
float _Imaginary x;      // imaginary 32-bit number
double _Complex y;       // complex 64-bit number
long double _Complex z;  // complex 80-bit number  
  \end{lstlisting}
NOTE: <complex.h> has \verb!_Imaginary! and complex as \verb!_Complex!; and
\verb!_Complex_I! or \verb!_Imaginary_I! as the imaginary unit. PLAN: new
programs should use complex and imaginary instead of \_Complex and \_Imaginary
  
This is so that legacy C programs can use complex and imaginary as
identifiers; new programs should use complex and imaginary instead of \_Complex
and \_Imaginary.
  
  \item IEEE 754 floating-point
\end{enumerate}

NOTE: \verb!long double! type is now supported in STL with functions operating
on \verb!long double!, e.g. sinl() or strtold() [str-to-long-double]. 
 
C89 doesn't have a boolean type, \verb!bool! is indeed a macro (which can be
undefined or redefined for your own purposs). In C99, \verb!_Bool! is defined as
an intrinsic data type. To make old code compatible with C99, i.e. making
\verb!bool! as an alias  for \verb!_Bool!, we include \verb!stdbool.h!
\footnote{\url{http://stackoverflow.com/questions/1921539/using-boolean-values-in-c}}.
\begin{lstlisting}
 _Bool x = 1;
  bool y = true;

  printf("%d", x);
  printf("%d", y);
\end{lstlisting}
NOTE: This is the transition that eventually (which may takes a decade or two),
\verb!bool! becomes the intrinsic type, and \verb!_Bool! deprecated.

Option 4: this is the standard way to use in C99
\begin{lstlisting}
#include <stdbool.h>
int main()
{
  bool b = false;
  b = true;
}
\end{lstlisting}


\textcolor{red}{The complex floating-point variables are not part of C++
language}.
\begin{enumerate}
  \item  {\bf \_Complex}: it has the same alignment and size of a 2-element array of the
corresponding floating-type type.

  \item {\bf \_Imaginary}: it has the same alignment and size of the
  corresponding floating-type type.
\end{enumerate}


The question is how to print numbers of the two following types? To retrieve the
real and imaginary part, we use \verb!<complex.h>! and 2 functions:
\verb!cimag()! and \verb!creal()!. Without \verb!<complex.h>!, we can code as
\footnote{\url{https://blogs.oracle.com/dew/entry/printing_c_language_complex_and}}
\begin{lstlisting}
#include <stdio.h>
#define   str(s)      #s
#define   xstr(s)      str(s)
#define   T      float
#define   CRe(T, z)   ((T \*) &z)[0]
#define   CIm(T, z)   ((T \*) &z)[1]
#define Im(T, z)   ((T \*) &z)[0]

int
main(void) {
   T _Complex a = 3.0F + 4.0F \* _Imaginary_I;
   T _Imaginary b = a;
   T g;

   g = (T) a;
   (void) printf("g=(" xstr(T) ")(%f, %f)=%f \\n",
      CRe(T, a), CIm(T, a), g);
   (void) printf("_Imaginary b = (%f)\\n", Im(T, b));
   return(0);
}

\end{lstlisting}


\subsection{'inline' function}
\label{sec:inline_C99}

The point of making a function {\it inline} is to tell the compiler to make some
extra efforts in optimization so that the function can be called faster. 

\begin{mdframed}


When the program executes the function call instruction the CPU stores the
memory address of the instruction following the function call, copies the
arguments of the function on the stack and finally transfers control to the
specified function. The CPU then executes the function code, stores the function
return value in a predefined memory location/register and returns control to the
calling function. This can become overhead if the execution time of function is
less than the switching time from the caller function to called function
(callee).

For functions that are large and/or perform complex tasks, the overhead of the
function call is usually insignificant compared to the amount of time the
function takes to run.

Remember, inlining is only a request to the compiler, not a command. Compiler
can ignore the request for inlining.

\end{mdframed}

What the compiler  typically does (but NOT guarantee it does) 
is to replace the function call by substituting
the code of that 'inline' function into its caller. So, it can eliminate the
overhead of a function call. 
However, the compiler CANNOT perform code replace if
\begin{enumerate}
  \item If a function contains a loop. (for, while, do-while)
  
  \item  If a function contains static variables.

In an inline function,
\verb!static! local variable is not allowed to be defined. 

  \item In C, any function, except \verb!main()!, can be
defined as inline with the \verb!inline! keyword.

  \item If a function is recursive. 
  
  \item If a function return type is other than void, and the return statement doesn’t exist in function body.

  \item If a function contains switch or goto statement.
\end{enumerate}

\begin{mdframed}

Disadvantage of \verb!inline! function:
\begin{enumerate}
  \item The added variables from the inlined function consumes additional registers,
  
  So, the in-lining function, if variables number which are going to use register
  increases, may create overhead on register variable resource
  utilization.
  
  \item If you use too many inline functions then the size of the binary executable file will be large, because of the duplication of same code.
  
  \item Too much inlining can also reduce your instruction cache hit rate, thus
  reducing the speed of instruction fetch from that of cache memory to that of
  primary memory.

  \item may increase compile time overhead if someone changes the code inside the inline function then all the calling location has to be recompiled
  
  \item may not be useful for many embedded systems. Because in embedded systems code size is more important than speed.
  
  \item might cause thrashing because inlining might increase size of the binary executable file.
  
  Thrashing in memory causes performance of computer to degrade.
  
\end{enumerate}
\end{mdframed}


Also, C language treats inline functions (by default) as having {\it static
linkage} (internal linkage), i.e. they are only visible within the translation
unit (Sect.\ref{sec:translation-unit}). So, two inline functions of the same
name can co-exist in two different translation units.
It means that an inline function must be used by functions defined in the same
file (or same translational unit).


For C++, i.e. to use \verb!inline! inside a class, see
Sect.\ref{sec:inline_C++98}.


There are different ways to use:
\begin{enumerate}
  \item Function definition and declaration all have \verb!inline!; but never
  use \verb!extern!.
\begin{lstlisting}
// a declaration mentioning inline
inline int max(int a, int b);


.... other codes that can use max()

// a definition mentioning inline
inline int max(int a, int b) {
  return a > b ? a : b;
}
\end{lstlisting}
  This is 'by definition' in C99, an {\it inline function}. In one {\it
  translation unit} (Sect.\ref{sec:translation-unit}). 
  
   
\end{enumerate}

What if a function definition has \verb!inline!, but its declaration doesn't
mention inline or use \verb!extern!?  NOTE: \verb!extern! cannot be used with
\verb!inline! function, as the inline function is not allowed to be from another
translational unit, but must be from the same translational unit.


Example 1
\begin{lstlisting}
// a declaration mentioning extern and inline
extern inline int max(int a, int b);

// a definition mentioning inline
inline int max(int a, int b) {
  return a > b ? a : b;
}
\end{lstlisting}

Example 2:
\begin{lstlisting}
// a declaration not mentioning inline
int max(int a, int b);

// a definition mentioning inline
inline int max(int a, int b) {
  return a > b ? a : b;
}
\end{lstlisting}


\subsection{'variadic' macro}
\label{sec:macro_variadic}

Now, a macro can be defined to accept a variable number of arguments much as a
function can. So, the syntax of defining a variadic macro is similar to defining
a function. In C++11, variadic macro is a part of the standard.
\begin{verbatim}
 #define eprintf(...) fprintf (stderr, __VA_ARGS__)
\end{verbatim}

To stop

 It's macro of variable 'arity'.
 

 
 References:
 \begin{enumerate}
   \item
   \url{http://cplusplus.co.il/2010/07/17/variadic-macro-to-count-number-of-arguments/}
 \end{enumerate}


\subsection{\#pragma}
\label{sec:pragma}

Using \verb!#pragma! to provide additional information to the compiler, beyond
what is conveyed by the language itself. The C compiler is free to add any
meaning to the pragms. Before compiling the code, the compiler will scan the
code to detect these pragmas and replaced by the proper C-standard equivalent
code.

Three forms of this directive was specified in C99 standard.

\subsubsection{\#pragma pack}

COMPILER TO SUPPORT: Visual C++,

COMPILER NOT TO SUPPORT: Turbo C/C++

\verb!#pragma pack()! is widely used in firmware developer. Other than that, you
are not recommended to use. You use it when you want the structure to match an
exact layout, e.g. writing device drivers that access hardware registers,
storage protocols or network protocols. It makes the structure smaller by
eliminating all padding between struct members; yet it makes accessing these
members much more expensive since the memory no long falls along the required
alignment. In other words, the compiler needs to add extra instruction to safely
access the struct members, or the programmers have to access byte-by-byte and
reconstruct the \verb!int! manually. 

When using packed structure, it's impossible to dereference a pointer to a
member of the struct (unless the microprocessor support unaligned pointer
accesses). An example: with misaligned data, accessing the data using C-language
intrinsic command like \verb!scanf()! can corrupt the program.
\begin{verbatim}
struct foo {
    char a;
    int b;
} bar;

scanf("%d", &bar.b)
\end{verbatim}
as \verb!bar.b! is not a valid \verb!int*!.

Example: read an \verb!int! on V850E (a popular microcontroller in the embedded
systems)
\footnote{\url{http://stackoverflow.com/questions/7822798/when-should-we-not-use-pragma-pack}}
\begin{verbatim}
LD.W        a[zero],r5
\end{verbatim}
with unaligned data, it requires many more instructions
\begin{verbatim}
LD.BU       g+3[zero],r1
SHL         8,r1
LD.BU       g+2[zero],r6
OR          r1,r6
SHL         8,r6
LD.BU       g+1[zero],r7
OR          r6,r7
SHL         8,r7
LD.BU       g[zero],r1
OR          r7,r1
\end{verbatim}

NOTE: 
\begin{itemize}
  \item \verb!#pragma pack()!: reset to default packing
  \item \verb!#pragma pack(1)!: use 1byte-packed
  \item \verb!#pragma pack(push)!: push current packing to stack, so that we can
  use something different
  \item \verb!#pragma pack(pop)!: pop the saved packing from stack (reset) 
\end{itemize}

Example: using \verb!#pragma pack!, here the structure below has total 6-byte on
a 32-bit system. The directive below works in GCC, Microsoft Visual C++, Borland
C++Builder
\begin{verbatim}
#pragma pack(push)  /* push current alignment to stack */
#pragma pack(1)     /* set alignment to 1 byte boundary */
 
struct MyPackedData
{
    char Data1;
    long Data2;
    char Data3;
};
 
#pragma pack(pop)   /* restore original alignment from stack */
\end{verbatim}

Example: using \verb!__attribute__(packed)! 
\begin{verbatim}
struct MyPackedData
{
    char Data1;
    long Data2 __attribute__((packed));
    char Data3;
};
\end{verbatim}
\section{C11}
\label{sec:C11-intro}


Works on the new C standard started in 2007. The current standard, approved in
2011, known as C11 (ISO/IEC 14882:2011). 
\begin{enumerate}
  \item type generic macros
  
  \item anonymous structures and unions
  
  \item improved Unicode support
  
  \item atomic operations
  
  \item multi-threading %- Sect.\ref{sec:multithreading}
  
  \item bounds-checked functions
  
  \item improve compatibility with C++
\end{enumerate}
 
NOTE: Many of the features haven't been widely implemented yet.

\subsection{Unicode}
\label{sec:C11_unicode}

Unicode characters can be embedded within C source code by using \verb!\uDDDD!
encoding (where DDDD denotes a Unicode character code).
 
% \cprotect\subsection[\_Noreturn]{\_Noreturn (\verb!__attribute__!((noreturn)))
% attribute}
% \cprotect[om]\subsection[\_Noreturn]{\_Noreturn
% (\verb!__attribute__!((noreturn))) attribute}
\subsection[\_Noreturn]{\_Noreturn (\_\_attribute\_\_((noreturn))) attribute}
\label{sec:_Noreturn}

Even the \verb!void! function return no value, it still return the control to
the caller. To tell the compiler that the function doesn't return the control to
the caller, i.e. there is no need to put the return address on the stack, which
saves the state of the registers. This can be useful for optimization, i.e.
there is no need to push the return address on the stack, save the state of the
registers, etc. all the compiler does is to pass the arguments and do a
\verb!jmp! to the start of the function. 
 

C11 supports this by adding a new keyword \verb!_Noreturn! or (if we include the
header <stdnoreturn.h>) \verb!__attribute__((noreturn))!. This is typically used
for a dead code.


They are equivalent to \verb![[no return]]! in C++11
(Sect.\ref{sec:[[noreturn]]}).
  


\begin{verbatim}
// C11
static _Noreturn void die(const char *fmt, ...) {
  /* print a formatted msg and exit */
  exit(EXIT_FAILURE);
}


// C11
#include <stdnoreturn.h>

static __attribute__((noreturn)) void die(const char *fmt, ...) {
  /* print a formatted msg and exit */
  exit(EXIT_FAILURE);
}

int main(){
   if (!whatever) {
      die("Something's wrong");
   }
}
\end{verbatim}

The compiler options:
\begin{itemize}
  \item \verb!-Wno-return! : 
  \item \verb!-Wunreachable-code!: 
  \item \verb!-Wmissing-noreturn!: 
\end{itemize}

\subsection{multi-thread programming}
\label{sec:C11_threads}

Check Sect.\ref{sec:thread-C11}.

\subsection{atomic operations}
\label{sec:C11_atomic_op}

Atomic operations typically perform a read-modify-write sequence on a memory
address, during which no other threads can modify the value of that data memory.
Many applications need atomic functions, e.g. reduction sum of an array. 

C11 standard now supports built-in atomic types - seems like it would naturally
be of interest to the kernel development community; for the first time, the
language standard tries to address concurrent access to data on contemporary
hardware.

Before the availability of atomic operations, i.e. the implementation being made
available in glibc, GCC-compatible compilers, e.g.
icc and Clang\footnote{\url{http://clang.llvm.org/index.html}}, use
\verb!_sync_*! family of built-in functions (originally designed for Intel
Itanium architecture).

\begin{mdframed}

Before the available of atomic operations, the kernel provides a small set of
atomic types now, along with a set of operations to manipulate those types.
Kernel atomics are a useful way of dealing with simple quantities in an atomic
manner without the need for explicit locking in the code.

\url{https://lwn.net/Articles/586838/}
\end{mdframed}

C11 take its model directly from C++11 (Sect.\ref{sec:C++11_atomic}).
In C11, to specify an atomic integer, we use \verb!_Atomic()! type specifier 
\begin{lstlisting}
_Atomic(int) counter;
\end{lstlisting}


References:
\url{http://www.informit.com/articles/article.aspx?p=1832575&seqNum=2}

\section{POSIX C specification}
\label{sec:POSIX-C-specification}

\begin{mdframed}

POSIX, for example, redefines all standard C header files (sometimes augmenting
them with advanced functionality), and uses the following statement in its
documentation:
\begin{verbatim}

The functionality described on this reference page is aligned with the ISO C
standard. Any conflict between the requirements described here and the ISO C
standard is unintentional. This volume of POSIX.1-2008 defers to the ISO C
standard.
\end{verbatim}


A POSIX-compliant system should have a C library that implements
APIs specified in all POSIX C header files. It was developed at the same time as
the ANSI C standard (i.e. C89).
The specification is defined in a set of header files.

\end{mdframed}


POSIX C is a superset of the standard C specification, and is expected to be for
POSIX systems. NOTE: Sockets, file descriptors, shared memory etc. are all part
of POSIX, but do not exist in the C library.

So, besides the header files defined for C standard library
(Sect.\ref{sec:C-standard-library}), POSIX C library provides
\begin{verbatim}

<aio.h> 	<arpa/inet.h> 	<assert.h> 	<ctype.h>
<dirent.h> 	<dlfcn.h> 	<fcntl.h> 	<fmtmsg.h>
<fnmatch.h> 	<ftw.h> 	<glob.h> 	<grp.h>
<iconv.h> 	<langinfo.h> 	<libgen.h> 	<monetary.h>
<mqueue.h> 	<ndbm.h> 	<net/if.h> 	<netdb.h>
<netinet/in.h> 	<netinet/tcp.h> 	<nl_types.h> 	<poll.h>
<pthread.h> 	<pwd.h> 	<regex.h> 	<sched.h>
<search.h> 	<semaphore.h> 	<spawn.h> 	<strings.h>
<stropts.h> 	<sys/ipc.h> 	<sys/mman.h> 	<sys/msg.h>
<sys/resource.h> 	<sys/select.h> 	<sys/sem.h> 	<sys/shm.h>
<sys/socket.h> 	<sys/stat.h> 	<sys/statvfs.h> 	<sys/time.h>
<sys/times.h> 	<sys/types.h> 	<sys/uio.h> 	<sys/un.h>
<sys/utsname.h> 	<sys/wait.h> 	<syslog.h> 	<tar.h>
<termios.h> 	<trace.h> 	<ulimit.h>
<unistd.h> 	<utime.h> 	<utmpx.h> 	<wordexp.h>
\end{verbatim}


\verb!pthread.h! is used for POSIX threads 
and is part of the C library (Sect.\ref{sec:pthread}); while \verb!threads.h!
is a header for C11/C++11 for multi-thread support implemented in C11
specification (Sect.\ref{sec:multi-thread-C11}).

Perhaps pthreads will be deprecated sometime in the future in favor of the
C11/C++11 ones; but not for a given timeline. Therefore if you want portability
you should prefer pthreads for now. If portability is not a concern, and you
have C11/C++11 threads available, you should probably use those.

The implementation of POSIX C specification is called POSIX C library.
\verb!glibc! is one library that implement POSIX C (Sect.\ref{sec:glibc}).


\section{C Standard Library: implementation of the standard C language
specification}
\label{sec:C-standard-library}


IMPORTANT: For a language specification, there can be different implementations. 

C Standard Library refers to the library implementing low-level APIs for C
language specification, whose interfaces are provided via a set of header files
(e.g. for ANSI C language - Sect.\ref{sec:ANSI-C}) and provides macros, type
definitions, and functions for tasks like string handling, mathematical
operations, I/O, memory allocations, and several other operating system
services.


There can be different implementations for the C standard library, and is
distributed as a shared library file for each O/S.
\begin{enumerate}

  \item In Linux-based O/S, they can utilize one of the following
\textcolor{blue}{different implementations}: glibc (Sect.\ref{sec:glibc}),
Bionic (used in Android), dietlibc, uClibc, Newlib, Klibc, musl, eglibc, etc.

\textcolor{red}{In Linux environment, the most important and widely used
implementation of standard C specification in GNU O/S is glibc}
(Sect.\ref{sec:glibc}).

In embedded systems, we use \verb!uClibc! (Sect.\ref{sec:uClibc})
\url{http://www.uclibc.org/about.html}. If the file server support 12TB of
storage or above, then using glibC is recommended.

A derivation of BSD's standard C library code targetting Android O/S for Linux
kernel is called  {\bf Bionic libc}. Bionic libc is much smaller than GNU C
library (glibc) and somewhat smaller than \verb!uClibc!. It is designed
for CPU at relatively low clock frequencies.

{\bf dietlibc} is a C standard library which was developed from scratch and thus
only implements the most important and commonly used functions. It is mainly
used in embedded devices. 

{\bf Newlib} is another implementation of standard C library; which is being
used in Cygwin, AmigaOS version 4, and in commercial GCC distributions by Red
Hat, CodeSourcery, Code Red. 

  
  \item In Windows: CRT - Sect.\ref{sec:CRT}

The Microsoft implementation of C standard library for  Windows is called C
Runtime Library (CRT) (Sect.\ref{sec:CRT}).

\end{enumerate}



% An implementation on Linux-based OS is \verb!stdlib!.

\begin{mdframed}
For C++ Standard Library, see Sect.\ref{sec:C++_Standard_Library}.
The superset of C standard library is POSIX C library
(Sect.\ref{sec:POSIX-C-library}). 

Compared to other languages like Java, .NET framework, C standard library does
not include a standard set of "container types" like the C++ Standard Template
Library, let alone the complete graphical user interface (GUI) toolkits,
networking tools, and profusion of other functionality that Java and the .NET
Framework provide as standard. The main advantage of the small standard library
is that providing a working ISO C environment is much easier than it is with
other languages, and consequently porting C to a new platform is comparatively
easy.


\end{mdframed}

In order to use an API from C standard library, we need to include a proper
header file in the C code
\footnote{\url{http://en.wikipedia.org/wiki/C_standard_library}}. 

%There are total 18 header files.
The number of header files increases with the version of C language
specification that the library implements. 
Sect.\ref{sec:macro-detect-compiler-version} describes how to detect which
version of C language is supported by the compiler to write the proper code
\begin{enumerate}
  
  \item Header files in C89: 
  
  <assert.h> (Sect.\ref{sec:C89_assert}), <ctype.h>,
  <errno.h>, <float.h>, <limits.h>, <locale.h> (Sect.\ref{sec:C89_locale}),
  <math.h>, <setjmp.h>, <signals.h>, <stdarg.h> (check arguments passed to
  functions), <stddef.h> (Sect.\ref{sec:stddef.h}), <stdio.h>
  (Sect.\ref{sec:C89_IO}), <stdlib.h> (pseudo-random number generators, memory
  allocations, numeric conversion functions), <string.h> (string handling that
  use \verb!char! as type unit which is
  8-bits\footnote{\url{http://en.wikipedia.org/wiki/C_string_handling}}),
  <time.h> (date time handling),
  
  \item Header files in C95:  3 more header files
  
  <iso646.h> (Sect.\ref{sec:iso646.h}), <wchar.h> (wide-string that uses
  \verb!wchar_t! as type unit which is at least 16-bites), <wctype.h>.
  
  \item Header files in C99: 6 more header files 
  
  <complex.h> (Sect.\ref{sec:complex}), <fenv.h>, <inttypes.h>, <stdbool.h>,
  <stdint.h>, <tgmath.h> (type-generic mathematics functions)

IMPORTANT:
\begin{verbatim}
//C++98
#include <tgmath.h>
#include <math.h>

//C++11
#include <cmath>
\end{verbatim}  

  \item Header files in C11: 5 more header files (giving total 29 header files) 
  
  <stdalign.h> , <threads.h> (multi-threading Sect.\ref{sec:C11_threads}),
  <uchar.h> (Unicode characters Sect.\ref{sec:C11_unicode}).

\end{enumerate}

\begin{minipage}[t]{0.4\textwidth}
C11:
\begin{tabular}{@{}p{1\linewidth}@{}}
<assert.h>
<inttypes.h>
<signal.h>
<stdio.h>
<wchar.h>
<complex.h>
<iso646.h>
<stdalign.h>
<stdlib.h>
<wctype.h>
<ctype.h>
<limits.h>
<stdarg.h>
<string.h>
<errno.h>
<locale.h>
<stdbool.h>
<tgmath.h>
<fenv.h>
<math.h> \verb!   !
<stddef.h>
<time.h>
<float.h>
<setjmp.h>
<stdint.h>
<uchar.h>
\end{tabular}
\end{minipage}
\begin{minipage}[t]{0.1\textwidth}
\verb!  !
\end{minipage}
\begin{minipage}[t]{0.4\textwidth}
C99:

<assert.h>
<iso646.h>
<setjmp.h>
<stdio.h>
<wchar.h>
<ctype.h> \verb!  !
<limits.h>
<signal.h>
<stdlib.h>
<wctype.h>
<errno.h>
<locale.h>
<stdarg.h>
<string.h>
<float.h>
<math.h>
<stddef.h>
<time.h>
\end{minipage}

\section{Simula to C++}

In 1979, Bjarne Stroustrup was working with Simula. Simula 67 language
was the first language to support object-oriented programming paradigm. Stroustrup found
that this paradigm was very useful for software development, but Simula is too
slow. So he began working on ``C with Classes'', to add object-oriented
programming into C language. First object-oriented features added to ``C
with Classes" were classes, basic inheritance, inlining, default function
arguments, and strong type checking.

The first C with Classes compiler was \verb!Cfront!, derived from C compiler
\verb!CPre!, which translates C with Classes code to ordinary C. Cfront was
abandonned in 1993 as some new features (e.g. C++ exceptions) couldn't be
incorporated easily.

In 1983, the language C++ was officially named as a new programming language.
New features: virtual functions (Sect.\ref{sec:C++98_virtual-functions}),
function overloading, references with \& symbol, \verb!const! keyword,
single-line comment with two forward-dashes (//; a feature taken from BCPL).

In 1985, the first book ``The C++ Programming Language'' came out and C++ was
implemented as a commercial product.

In 1998, ISO Committee for Standard C++ (WG21) published the first C++ standard,
known as C++98 (Sect.\ref{sec:C++98}). New features: STL (standard template
library).

In 1989, new features: protected and static members, inheritance from several
classes. 

In 1990, the second important book ``The Annotated C++ Reference Manual'' came
out. 


In 2003, a new standard came out to resolve many problems reported earlier,
known as C++03.

In 2005, a technical report (TR1, ISO/IEC TR 19768, C++ Library Extensions) was
released with planning new-features for the upcoming standard C++0x (as it's
expected to be released before 2010) under the namespace \verb!std::tr1::!.
However, the new standard was not available until mid-2011, known as C++11. TR1
drafted new features like: smart pointers, hash tables, random number
generators, regular expressions, etc.
\footnote{\url{http://en.wikipedia.org/wiki/C++_Technical_Report_1}}. Many
of these features have become standard in C++11.

The {\bf Boost} library project made a big impact on the new standard.
New features: regular expression, comprehensive randomization library, new C++
runtime library, atomics support, STL (standard threading library), new
\verb!for loop! syntax, \verb!auto! keyword, new container classes, better
supports for \verb!unions! and array-initialization lists, and variadic
templates.


References: \url{http://www.cplusplus.com/info/history/}
 
\section{C++98}
\label{sec:C++98}

C++98 is the first standard of C++ language. It is aka ISO/IEC 14882:1998. 

\subsection{C++ standard template library (STL)}
\label{sec:C++98_STL}
\label{sec:C++_STL}

\textcolor{red}{Many people confuse that C++ Standard Template Library and STL
are the same. In fact, they are not}
\footnote{\url{http://stackoverflow.com/questions/5205491/whats-this-stl-vs-c-standard-library-fight-all-about}}.
\begin{itemize}
  \item STL is a library developed by Alexander Stepanov who was the pioneer in the
concept of {\it generic programming} in C++ that adopt Generics from Ada
programming language, i.e. writing the code without explicitly telling the data
type (i.e. the container) of the input/output until you use that container.

Stepanov realized that C/C++ pointers allow flexible access to data storage that
C language has a powerful feature, pointer. However, C has limited set of data
types. Even though C has structure that allows you to build up more complicated
data type; it doesn't allow you to define operations on the structures. C++ with
object-oriented feature allows generic programming easier.

  \item C++ Standard Template Library is the implementation of a number of widely-used containers,
  whose syntax and methods to operate on data is  a major part
  of C++ standardization since C++98 (Sect.\ref{sec:C++_Standard_Library}).
  
  C++ STL  inherits many features from the STL library  which is crucial for
  achieving generality without losing efficiency.

\end{itemize}

% \begin{tabular}[t]{p{10cm}}
% 
% \end{tabular}
\begin{mdframed}

The fundamental points: algorithms are defined based on algebraic structures.
``Generic programming is a programming method that is based in finding the most
abstract representations of efficient algorithms'' (Stepanov). Stepanov wanted
to find a generic representations for each well-known algorithm. He thus
developed STL. Some versions of
STL can be checked here: \url{http://www.sgi.com/tech/?/STL}.

STL, and then C++ Standard Library, incorporated many complicated data
structures known as {\bf containers} (e.g. map, single/double linked-list,
hash-table,  associative map (paired array), vector (expandable array), rope
(large string storage and manipulation), etc.) whose data elements can be any
data type (Chap.\ref{chap:containers}). 

A common trait among these container is the ability to change their size during
the execution of the program, i.e. dynamic size. To achieve this, some form of
dynamic memory allocation is required. 

Thus, each container needs to have an associated  {\bf allocator}, a mechanism
that can encapsulate memory handling and is independent of the underlying {\bf
memory model} (which by that time is not part of the C++ language) - Sect.\ref{sec:containers}).
Allocator handles all memory allocation and deallocation for a given container.
The complete abstraction of the memory model (i.e. it doesn't matter whether the
object is int or double or a complex data structure), the way we interact with
data element is always the same.
 

Besides it nees an allocator, a container also needs an {\bf iterator} (Sect.\ref{sec:C++98_iterators}).
An iterator provides the capability to traverse through every elements in the
container. An iterator is a union of two theories: (1) theory of name (a name is
something that point to something else); (2) theory of successor operation (++).
Two iterator are equal if and only if they point to the same object, i.e.
\begin{verbatim}
i == j iff &*i == &*j
\end{verbatim}
A {\bf stride iterator} is a sequence of iterator that is $n$ steps apart.
\begin{verbatim}
template <class T>
T& operator*(T& x) { return x;}

template <class T>
const T& operator*(const T& x) { return x;}
\end{verbatim}
In STL, \verb!set!, \verb!multiset!, \verb!map! and \verb!multimap! were
implemented using red-black tree data structure.

Early version of STL assumed the size of a {\bf container} is an integer type
\verb!std::size_t!, and the distance between two iterators is of type
\verb!ptrdiff_t!. 

\end{mdframed}


To provide generic programming, C++ added function template
(Sect.\ref{sec:function-template}) and class template
(Sect.\ref{sec:classs-template}) which can adopt more than one type (or class)
without requiring programmer to rewrite the entire same code for each type.
This is aka a {\bf generic type} as mentioned earlier. 

C++98 Standard Template Library includes components:
algorithms, containers, functional, and iterators.  The integration of C++
Standard Template Library  into C++ make C++ programming more easier.

These are ready-made classes that can be used with any built-in types; or
user-defined types that supports some elementary operations (e.g.
copying, assignment). These can be done using the concept of {\bf templates}.
\begin{enumerate}
  \item containers - Sect.\ref{sec:C++98_containers}
  
  \item allocators

Generic programming that allows dynamic size, however, may incur performance
penalties. To avoid this, C++ adopted this as a standard but impose more
restrictive requirements (Sect.\ref{sec:C++98_allocators}). C++11 redefine total
new allocator (Sect.\ref{sec:C++11_allocators}).
  
  \item iterators - Sect.\ref{sec:C++98_iterators}
\end{enumerate}
%C++'s container (Sect.\ref{sec:C++98_containers}) has adopted STL library. To
%enable generic programming, {\bf template} is used in C++
%(Sect.\ref{sec:C++98_template}). 

% To iterate from one data element to the next
% one in a container, an {\bf iterator} is used (Sect.\ref{sec:C++98_iterators}).
Any code that use generic metaprogramming is called template library. 

One of the implementation of this C++ Standard Template Library-specification is
\textcolor{red}{STLport}
\footnote{\url{http://stlport.sourceforge.net/FAQ.shtml}} which provides a
portable code on different platforms and stricter guarantees than ISO C++ on
container behavior and algorithm complexity. Another, more popular,
implementation of C++98 STL is \verb!stdlib!. 




\begin{mdframed}

{\bf Template member functions} were used heavily to construct any kind of a
container from any other kind's of a container. The second most important feature is
{\bf template arguments} which are template themselves. Consider an example that
swap two object of type $T$ class
\begin{verbatim}
swap(T&, T&)
\end{verbatim}
To make it works with any kind of data, we need to have the corresponding
\verb!swap<int>! for that data type. This put more effort for the programmer.
To allow the compiler to find the closest match, e.g.
\begin{verbatim}
template <class T> void swap(vector<T>&, vector<T>&);
\end{verbatim}

{\bf Partial specialization} allows, not going into detail of the structure of
the data type $T$, so it can achieve constant time, we just move a couple of
pointers in the vector headers. Otherwise, 3 arguments to do swap need to
be used (which copies vectors 3 times) which takes linear time. This would allow
\verb!sort! operation that works on vectors of vectors much faster. 
\begin{verbatim}
template <class T> T ** copy(T**,T**,T**);
\end{verbatim}
With partial specialization, \verb!memcpy! is used to copy a range of pointers,
and we don't have to worry about construction, destruction. However,
{\bf particular specialization} can also be used of algorithms for some data
types.

\end{mdframed}


% and use template (Sect.\ref{sec:C++98_template})

\subsection{assert() in C++}
\label{sec:assert-in-C++}

To use C's \verb!assert! macro (Sect.\ref{sec:assert_C}) in C++, we use
\begin{verbatim}
#include <cassert>
\end{verbatim}

A better solution is to consider using something like \verb!zmq_assert(x)!
(Sect.\ref{sec:assert-in-zmq}).


\subsection{zmq\_assert() in zmq library}
\label{sec:assert-in-zmq}

We include the header file \verb!err.hpp! in codes

An example in that file is given below:

\begin{verbatim}
//  This macro works in exactly the same way as the normal assert. It is used
//  in its stead because standard assert on Win32 in broken - it prints nothing
//  when used within the scope of JNI library.
#define zmq_assert(x)                                                          \
    do {                                                                       \
        if (unlikely (!(x))) {                                                 \
            fprintf (stderr, "Assertion failed: %s (%s:%d)\n", #x, __FILE__,   \
                     __LINE__);                                                \
            fflush (stderr);                                                   \
            zmq::zmq_abort (#x);                                               \
        }                                                                      \
    } while (false)

\end{verbatim}
\url{https://github.com/zeromq/libzmq/blob/master/src/err.hpp}



\subsection{containers}
\label{sec:C++98_containers}
\label{sec:containers_C++98}

In C++98, it adopts the concept of generic programming paradigm, as previously
proposed and implemented as an extension to C++ by Alexander Stepanov
(Chap.\ref{chap:containers}). 

C++98 Standard Template Library provides implementation of a number of widely-used
{\bf containers} which is defined as a holder object that stores a collection of
other objects.

\begin{enumerate}
  
  \item sequence containers (vector, dequeue, and list): Sect.\ref{sec:container_sequence}
  
  \item associative containers (set, multiset, map, and multimap):
  Sect.\ref{sec:container_associative}
\end{enumerate}

Others:
\begin{verbatim}
hash_map
hash_set
set
map
multiset
multimap
\end{verbatim}  

\subsection{-- vector, dequeue, list}
\label{sec:container_sequence-C++98}

std::vector (Sect.\ref{sec:std::vector}), std::dequeue
(Sect.\ref{sec:std::dequeue}), std::list (Sect.\ref{sec:std::list})

\subsection{-- set, map, multiset, multimap}
\label{sec:container_associative-C++98}

std::set (Sect.\ref{sec:std::set}), std::map (Sect.\ref{sec:std::map}).

In \verb!set! and \verb!map!, the key must be unique.  We use \verb!multiset! or
\verb!multimap! when we allows multiple instances of data elements to have the
same key. 

In usage, the main difference is in the member function \verb!cout()! and one of
the \verb!insert()! method
\footnote{\url{http://cs.stmarys.ca/~porter/csc/ref/stl/cont_set.html}}.

\subsection{-- pair}

std::pair (Sect.\ref{sec:std::pair}).

\subsection{-- hash\_map, hash\_set}

std::hash\_map (Sect.\ref{sec:hash_map}), std::hash\_set
(Sect.\ref{sec:hash_set})


\subsection{-- user-defined containers}

We also can define our own container using class template
(Sect.\ref{sec:C++98_template}). Depending on the data
structure being used, we can access the data element using one of the
methods given in Sect.\ref{sec:container-homogeneous-loop-through-data}).
%Check more details in Chap.\ref{chap:C++_containers}.

\subsection{'const' keyword}
\label{sec:const_C++}

The \verb!const! keyword was added to C++ since the first version C++98. Unlike
that in C, the meaning of \verb!const! object is different in C++, as here the
content of the object cannot be changed. So, the \verb!'const'! object must be
initialized.
\url{http://stackoverflow.com/questions/6087729/const-in-c-vs-const-in-c}. So,
if the variable is an object of a given class, a default constructor must be
defined for that class.

A \verb!const! object can be used as compile-time in C++, but not in C.

Another important factor is that a \verb!const! object in C++ has internal
linkage by default; while in C it has default external linkage
(Sect.\ref{sec:const_C})
\begin{verbatim}
int main()
{
   /*Unless explicitly declared extern, a const object does not have
 external linkage and must be initialized*/
   extern const int x; 
   return 0;
}
\end{verbatim}

Pointers to string literals must be an \verb!char const*! in C++ but in C it can
be \verb!char*!.

Assigning a regular pointer pointing to a location marked as read-only is called
{\bf down qualification} in C++. In C, it may throws a warning, but casting is
implicitly allowed at compile time (Sect.\ref{sec:type-cast-C}) and thus may
give unpredicted behavior at runtime. This, however, will raise an error in C++
during compile time.

\begin{Verbatim}
int i = 10;
int const j; // error in C++, as j cannot get any other value
             // once the code is compiled
             // so the compiler expect the programmer 
             // to assign an explicit value
int const j = 20;
 
    /* ptr is pointing an integer object */
int *ptr = &i; 

  /* Down qualification */
  /* after this, it removed the const-ness from the expression &j */
ptr = &j;    
    
\end{Verbatim}
When {\bf down qualification} occurs, the value in read-only memory can be
modified unexpectedly via a regular pointer. The consequences are implementation
dependent, and the program may fail at runtime.  Assigning \verb!int *! object
to \verb!const int *! is a down qualification, and thus raises a compilation
warning in C, and an error in C++.
\footnote{\url{http://www.dansaks.com/articles/1999-02 const T vs T const.pdf}}


\subsection{'constexpr' (C++14)}
\label{sec:constepxt_C++14}

NOTE: \verb!const! declares an object as constant.
This implies a guarantee that, once initialized, the value of that object won't
change, and the compiler can make use of this fact for optimizations.
\begin{itemize}
  
  \item  \verb!const! can only be used for non-static member functions, not functions in general. 
  
  If used with a member function, it gives a guarantee that the member function
  does not modify any of the non-static data members.
  
\end{itemize}

\verb!constexpr! implies \verb!const!.


Similar to \verb!const!, but \verb!constexpr! is different in that it declares
an object as fit for use in what the Standard calls \textcolor{red}{constant expressions}. 

It enables \verb!constexpr! to use  with a broader types of objects.

A \verb!constant expression! can comprise
\begin{itemize}
  \item  An object like N above can be used as constant expression without being declared constexpr


\begin{verbatim}
int main()
{
  const int N = 3;
  int numbers[N] = {1, 2, 3};  // N is constant expression
}
\end{verbatim}

  \item 
\end{itemize}

 \verb!constexpr! can also be used with
\begin{enumerate}
  \item an expression, that can be evaluated at compile-time.
  
\begin{lstlisting}
template<int X>
class fixed_size_list
{ /*...*/ };

fixed_size_list<X> mylist;  // X must be an integer constant expression

int numbers[X];  // X must be an integer constant expression
\end{lstlisting}


However, declaring something as constexpr does not necessarily guarantee that it
will be evaluated at compile time. It can be used for such, but it can be used
in other places that are evaluated at run-time, as well.



  \item   both member and non-member functions, as well as constructors

  
  It declares the function fit for use in constant expressions. 

The compiler will only accept it if the function meets certain criteria (7.1.5/3,4), most importantly
\begin{itemize}
  
  \item  (before C++14) The function body must be non-virtual and extremely simple: Apart from
  typedefs and static asserts, only a single return statement is allowed. In the
  case of a constructor, only an initialization list, typedefs and static assert
  are allowed. (= default and = delete are allowed, too, though.)
  
  As of C++14 the rules are more relaxed, what is allowed since then inside a
  constexpr function: asm declaration, a goto statement, a statement with a
  label other than case and default, try-block, definition of a variable of
  non-literal type, definition of a variable of static or thread storage
  duration, definition of a variable for which no initialization is performed.
  
  \item The arguments and the return type must be literal types (i.e., generally
  speaking, very simple types, typically scalars or aggregates)
  
\end{itemize}

  \item 
\end{enumerate}



\subsection{name mangling: function overloading}
\label{sec:name_mangling-function}
\label{sec:function_overloading}

At the lower level, two functions must have different names. 

At the programming level, C++ compilers allow programmers to write functions of
the same name, but accepting arguments of different data types or different
return data type. This is known as function overloadding.
However, to make sure the two functions are unique, the C++ compiler will map
them to different names using a technique called {\bf name mangling}, which
automatically rename these functions, by appending some additional characters.


E.g.
\begin{verbatim}
int  f (void) { return 1; }
int  f (int)  { return 0; }
void g (void) { int i = f(), j = f(0); }
\end{verbatim}
which becomes
\begin{lstlisting}
int  __f_v (void) { return 1; }
int  __f_i (int)  { return 0; }
void __g_v (void) { int i = __f_v(), j = __f_i(0); }
\end{lstlisting}

Essentially, the compiler modify the function names by adding a few leading or
trailing underscores and/or the name of the class (if the function is a class
method) which make the C code no longer able to recognize the C++ function
names.

\begin{verbatim}
int func() {}    --> int _func_() {}

class A
{
   int func() {}
}                --> int A_func_() {} 

namespace NS_A
{
class A
{
   int func() {}
}                 
}                --> int NS_A_A_func_() {}
\end{verbatim}

For variables, read Sect.\ref{sec:name_mangling}.

References: \url{http://en.wikipedia.org/wiki/Name_mangling}

\subsection{'inline' function}
\label{sec:inline_C++98}

An explanation of inline function is given in Sect.\ref{sec:inline_C99}. In
C++, there are some requirements.
\begin{enumerate}
  \item Beside static local variable, {\it string literals} are not allowed to
  be defined within the inline function.
  
  \item  In fact, all the functions if defined inside the class are implicitly inline, i.e. 
  the compiler tries to make it inline if possible.

EXCEPTION: cannot perform inlining if the function is virtual (Sect.\ref{sec:virtual_member-function}). The reason is
call to a virtual function is resolved at runtime instead of compile time.


\begin{lstlisting}
class S 
{ 
public: 
    inline int square(int s) // redundant use of inline 
    { 
        // this function is automatically inline 
        // function body 
    } //NOTE: This is considerd as bad programming practice
};
\end{lstlisting}
  The compiler will ignore if a member function does not meet all the
  restrictions of inline functions as defined in C language.
   
  The best programming style is to just write the prototype of function inside
  the class and specify it as an inline in the function definition.

\begin{lstlisting}
class S 
{ 
public: 
    int square(int s); // declare the function 
}; 
  
inline int S::square(int s) // use inline prefix 
{ 
  
}
\end{lstlisting}   
   
   \item inline function is a better way than using macros in C++ (Sect.\ref{sec:macro_C})
   
   macros are managed by preprocessor and inline functions are managed by C++ compiler.
   
   \item  it is only useful to make the function inline if the time spent during
   a function call is more compared to the function body execution time.
   
   Programming languages like Java and C\# doesn’t support inline functions.
   
   In Java, the compiler can perform inlining when the small final method is
   called, because final methods can’t be overridden by sub classes and call to
   a final method is resolved at compile time.
   
    In C\# JIT compiler can also optimize code by inlining small function calls
    (like replacing body of a small function when it is called in a loop).
    
   
\end{enumerate}

\subsection{macros}

See Sect.\ref{sec:macro_C} for definition of macros in C language.


\subsection{\_\_cplusplus}
\label{sec:__cplusplus}

When writing a single code that can be compiled into C or C++, we typically
check agains the definition of the macro
\verb!__cplusplus! as it is automatically defined by the C++ compiler when
compiling a C++ program
\begin{verbatim}
#ifdef __cplusplus 
  // put C++ code
#else
  // put C code
#endif
\end{verbatim}

If we want to check for different version of C++ compiler, from that a proper
C++ function can be used, for example.
\begin{enumerate}
  \item \verb!__cplusplus! is 1 : C++ pre-C++98
  \item \verb!__cplusplus! is 199711L : C++98
  \item \verb!__cplusplus! is unknonw (no way to check): C++98 + TR1
  
  \item \verb!__cplusplus! is 201103L : C++11
  \item \verb!__cplusplus! is 201402L : C++14
  \item \verb!__cplusplus! somevalue greater than 201402L : experimental
  language features
\begin{verbatim}
#if defined(__CXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)
  // C++ experimental code
#else
  // C++ standard code
#endif
\end{verbatim}
\end{enumerate}

Example:  a common usage is (Sect.\ref{sec:extern_''C''})
\begin{verbatim}
#ifdef __cplusplus
 extern "C" {
#endif

  // C code
  
#ifdef __cplusplus
 }
#endif
\end{verbatim}

\url{http://stackoverflow.com/questions/2324658/how-to-determine-the-version-of-the-c-standard-used-by-the-compiler}

\subsection{namespaces}
\label{sec:namespace_C++}

In addition to language defined scope (Sect.\ref{sec:scopes_in_C}), there are a
few language-defined namespace in C (Sect.\ref{sec:namespace_C}).
The goal is to allow the same identifier to be used in the same program.
% With variables, in C language, everything are within the same global scope,
% i.e. no two things are allowed to have the same name.
In C++, namespace is a high-level concept to allow user-defined scope in
addition to class for C++ language using
\verb!namespace! keyword. The C++ STL use a namespace called \verb!std!
(Sect.\ref{sec:C++_Standard_Library}).

\textcolor{red}{\bf IMPORTANT}: Never put 
\begin{lstlisting}
using namespace std;
\end{lstlisting}
inside a header file, as once the header file is included in different source
file, it will mess up the code.

Now, with the concept or {\bf namespace in C++}, we can put things into
different pre-defined or user-defined namespace.

\begin{verbatim}
#include <vector>

// case 1
using namespace std; //a using directive
int vector=99;vector<int> x; 


// case 2
using std::vector; //a using declaration
int vector=99;
vector<int> x;   
\end{verbatim}
\sloppy\url{https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/mysteries_of_namespaces?lang=en}




\subsection{Template}
\label{sec:C++98_template}
\label{sec:template-C++98}

\begin{mdframed}

By using compile-time polymorphism (Sect.\ref{sec:polymorphism}), it's more
efficient than using run-time polymorphism
(Sect.\ref{sec:runtime-polymorphism}). However, runtime polymorphism has its own
advantage, i.e. allow writing the code once, and works with different input data
type. However, using this abstraction has some penalty on the performance.
Modern (clever) C++ compilers, since C++11 (Sect.\ref{sec:C++11}), can minimize
this penalty, giving faster performance and coding faster. 
\end{mdframed}

A template is a form of compile-time polymorphism, i.e. it allows writing one
function, but works with different input data type(s). We can have a class
template, or a function template (Sect.\ref{sec:template-how-to-use}).

However, a template is not a class or a function, it's a pattern that the
compiler use to generate a family of classes or functions.  In other words, it
shifts the job from programmers to the compilers. Then, in order for the
compiler to generate the proper class, it must 'see' both the template
definition (including declaration), and the specific type that it has to
generate (read more at the end of the section).


Templates in C++ can be either
\begin{enumerate}
  \item type parameter: which can be a type, or a template
  \item non-type parameter: which can be a pointer, a reference, or integral
  constant expressions (Sect.\ref{sec:constant-expression})
\end{enumerate}

\subsection{-- how to write a template}
\label{sec:template-how-to-use}


A function template is not a function. It's a template for creating
multiple functions, as needed. Similarly, a class template is not a class, it's
a pattern for creating multiple classes, as needed.

Example: a class/struct template and inside is a function template
\begin{lstlisting}
template<typename T>
struct Foo
{
    T bar;
    void doSomething(T param) {/* do stuff using T */}
};

// somewhere in a .cpp
Foo<int> f; 
\end{lstlisting}

In the above example, at compile time, the compiler knows that we use \verb!int!
for the class Foo; and nothing else; so the compiler will create a new class.
Because of this, the compiler needs to be able to get access to the
implementation of the body of the function or class template.
\textcolor{red}{COMMON PRACTICE: you should keeep both the declaration
and the body in one file, i.e. header file}. 


There is a way to separate a template function with declaration in header file
and body in .cpp file, but it requires \verb!export! 
\begin{verbatim}
// ORIGINAL version of xyz.h
template <typename T>
struct xyz
 {
    xyz();
    ~xyz();
 };
\end{verbatim}
\textcolor{red}{and}
\begin{verbatim}
// ORIGINAL version of xyz.cpp
#include "xyz.h"

template <typename T>
xyz<T>::xyz() {}

template <typename T>
xyz<T>::~xyz() {}
\end{verbatim}

Remember that the real function is only created, if the template function is
called with a particular type. 
One way around this is to explicitly request the instantiation of xyz, in this
example of \verb!xyz<int>!. In a brute force effort, this could be added to
xyz.cpp by adding this line at the end of it:
\begin{verbatim}
template xyz<int>;
\end{verbatim}
To avoid modifying xyz.cpp, a less intrusive way to avoid that file is to
create another:
\begin{verbatim}
// xyztir.cpp
#include "xyz.cpp" // .cpp file!!!, not .h file!!

template xyz<int>;
\end{verbatim}



\subsection{-- type parameter, e.g. class template}

C++ allows {\bf class template} and {\bf template parameter}. 
\begin{itemize}
  \item Template parameters allow defining special functions (known as
  function template) that can operate on generic types. At the definition-phase
  \begin{lstlisting}
template <class myType>
myType GetMax (myType a, myType b) {
 return (a>b?a:b);
}
  \end{lstlisting}
with \verb!myType! represents a type that has not yet been specified. At the
place where we use it, it can apply to any type, by specifying which type being
used, e.g. adding \verb!<int>! after the function name
\begin{lstlisting}
int x,y;
GetMax <int> (x,y);

long l=10, m=5, n;
n=GetMax<long>(l,m);
\end{lstlisting}
\textcolor{red}{it's common to use big-T (i.e. T) as the template name; as it's
short and it's widely used in many other libraries}
\begin{lstlisting}
template <class T>
T GetMax (T a, T b) {
  return (a>b?a:b);
}
\end{lstlisting}


\item In a class template, the member function can also receive template
parameters.
\begin{lstlisting}
template <class T>
class mypair {
    T values [2];
  public:
    mypair (T first, T second)
    {
      values[0]=first; values[1]=second;
    }
};


template <class T>
T mypair<T>::getmax ()
{
  T retval;
  retval = a>b? a : b;
  return retval;
}
\end{lstlisting}
and then we use it
\begin{verbatim}
mypair<int> myobject (115, 36); 
\end{verbatim}
\end{itemize}

Example: If we have more than one template classes, the syntax is similar
\begin{lstlisting}
template <class T, class U>
T GetMin (T a, U b) {
  return (a<b?a:b);
}

int i,j;
long l;
i = GetMin<int,long> (j,l);
\end{lstlisting}

Example: we can also define {\it class template specialization}, which specify
the implementation for a particular type of the 'generic type' being used. In
particular, instead of using \verb!increase()! method, we want the method name
is \verb!uppercase()! when the input type is \verb!char!. Syntax: using an empty
template<> parameter list, and the <char> specialization parameter after the
class template name. IMPORTANT: {\it When we declare specializations for a
template class, we must also define all its members, even those exactly equal to the
generic template class, because there is no "inheritance" of members from the
generic template to the specialization}.  
\begin{verbatim}
template <> class mycontainer <char> { ... };
\end{verbatim}
The code is
\begin{lstlisting}
using namespace std;

// class template:
template <class T>
class mycontainer {
    T element;
  public:
    mycontainer (T arg) {element=arg;}
    T increase () {return ++element;}
};

// class template specialization:
template <>
class mycontainer <char> {
    char element;
  public:
    mycontainer (char arg) {element=arg;}
    char uppercase ()
    {
      if ((element>='a')&&(element<='z'))
      element+='A'-'a';
      return element;
    }
};
\end{lstlisting}

It's perfectly possible to template a class on an integer rather than a type,
then we can use that integer value (templated value) to assign to a variable, or
otherwise manipulate it in a way we might with any other integer literal:.

Example:
\begin{lstlisting}
template <int N>
struct Factorial 
{
     enum { value = N * Factorial<N - 1>::value };
};

template <>
struct Factorial<0> 
{
    enum { value = 1 };
};

// Factorial<4>::value == 24
// Factorial<0>::value == 1
void foo()
{
    int x = Factorial<4>::value; // == 24
    int y = Factorial<0>::value; // == 1
}
\end{lstlisting}

Example:  templates which can be used to pass a
number, e.g. array-size to the class.
\begin{lstlisting}
template <class T, int N>
class mysequence {
    T memblock [N];
  public:
    void setmember (int x, T value);
    T getmember (int x);
};

template <class T, int N>
void mysequence<T,N>::setmember (int x, T value) {
  memblock[x]=value;
}

template <class T, int N>
T mysequence<T,N>::getmember (int x) {
  return memblock[x];
}
\end{lstlisting}

Example: A default value can be used
\begin{lstlisting}
template <class T=char, int N=10> class mysequence {..};
\end{lstlisting}
So \verb!mysequence<> myseq;! is equivalent to \verb!mysequence<char,10> myseq;!

\begin{lstlisting}
template<unsigned int SIZE = 3>
struct Vector {
    unsigned char buffer[SIZE];
};

Vector<> test;
\end{lstlisting}

\subsection{nothing }

\begin{lstlisting}
template<>
struct Vector<3> {
    // alternative definition for SIZE == 3
};

\end{lstlisting}
which is equivalent to 
\begin{lstlisting}
template<unsigned int SIZE = 3>
struct Vector {
    unsigned char buffer[SIZE];
};

Vector<> test;
\end{lstlisting}
\url{http://stackoverflow.com/questions/499106/what-does-template-unsigned-int-n-mean}

\subsection{-- non-type parameter}

Example: {\bf non-type parameters} as passing a pointer to a function
\begin{lstlisting}
template<void (*F)()>
struct FunctionWrapper {
    static void call_it() { F(); }
};

// pass address of function do_it as argument.
void do_it() { }
FunctionWrapper<&do_it> test;
\end{lstlisting}

Example: passing a reference (e.g. to an integer)
\begin{lstlisting}
template<int &A>
struct SillyExample {
    static void do_it() { A = 10; }
};

// pass flag as argument
int flag;
SillyExample<flag> test;
\end{lstlisting}


Example: template a template
\begin{lstlisting}
template<template<typename T> class AllocatePolicy>
struct Pool {
    void allocate(size_t n) {
        int *p = AllocatePolicy<int>::allocate(n);
    }
};

// pass the template "allocator" as argument. 
template<typename T>
struct allocator { static T * allocate(size_t n) { return 0; } };
Pool<allocator> test;
\end{lstlisting}


\subsection{-- Pre C++11}

\textcolor{red}{IMPORTANT (Pre-C++11)}: When using a template within a template,
a space must be present between two brackets '>'. This is no longer required in
C++11
\begin{lstlisting}
std::vector<std::vector<double> >
\end{lstlisting}

\textcolor{red}{Explicit initialization}: By default, the compiler instantiate
the template on demand. As template is a pattern, a particular 
class is instantiated when the code really needs it. For example, Foo is defined
as a template that can accept a generic type. In your code you use
\begin{lstlisting}
Foo<int> f;   //generate code for the class Foo<int>
f.bar();      //along with the class member
\end{lstlisting}
implicit initialization is done when the compiler see the first line, i.e. it
creates the code for the \verb!int! version of the Foo. A
double-edge feature with both advantage and disadvantage of implicit
initialization is that (advantage) the unusuable methods is never compiled by
the compiler, code is smaller; (disadvantage) not all errors can be detected
when using that classes. If it's important to detect all possible errors, we can
tell the compiler to do {\it explicit initialization}
\footnote{\url{http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=549}}.
\begin{lstlisting}
template class Foo<int>;  

template void foo<int>;
\end{lstlisting}
Example: 
In the C++11 header file
\begin{lstlisting}
// File "foo.h"
template<typename T>
extern void foo();
\end{lstlisting}
then the actual implementation of the template function can be in a different
file
\begin{lstlisting}
// File "foo.cpp"
#include <iostream>
#include "foo.h"

template<typename T>
void foo()
{
  std::cout << "Here I am!\n";
}
 
 //MUST HAVE: explicit instantation
template foo<T>();
\end{lstlisting}
and then the file that use the template function just need to \verb!#include!
the header file
\begin{lstlisting}
// File "main.cpp"
#include "foo.h"

int main()
{
  foo<int>();
  ...
}
\end{lstlisting}

\textcolor{red}{Template declaration and definition:} When using template, C++
requires the entire template, i.e. the declaration and all method definitions
for the class to be written in a single translation unit
(Sect.\ref{sec:translation-unit}). The situation is that if one of your source
file (say main.cpp) use some template function or template class, and you write
the declaration of them in the header file, say abc.h, and the definition in the
source file, say abc.cpp. If you include the header file \verb!#include <abc.h>!
into main.cpp; the definition won't be in the same translation unit. The common
way is to dump everything (template declaration and definition) into the header
file (inline where possible, and out-of-line when necessary) and \verb!#include!
this header-file into the source file that uses it, e.g. main.cpp.
Another option, if you really want to using (header-file, source-file) is to
\verb!#include! the implementation (the source file) at the end of the header
file.\footnote{\url{http://stackoverflow.com/questions/36039/templates-spread-across-multiple-files}}.


\textcolor{red}{Template used in multiple translation units} (C++11): The main
problem is that if you have multiple translation units, that both use the same template,
you will end up compiling and generating multiple class instantiation of the same
template class in different file. This makes compilation time longer, and object
file size bigger.  When we know that the template has already been used and
instantiated somewhere else in the same binary, C++11 provided \verb!extern!
\verb!template! to tell the compiler not to generate an instance of the template
in this translation unit, as it already instantiated somewhere else. At first, you
need to have one source file that the template class gets explicitly initialized
(which we can use explicit initialization as described above), then in other
translation units, we just use \verb!extern template!
\begin{lstlisting}
extern template class Foo<int>;

extern template void foo<int> ();
\end{lstlisting}
One potential use is to create a sharing library. How? the header file contains
everything (template definition and declaration) and an \verb!extern template!
for the data type we really use (e.g. \verb!int!); while in the corresponding
.cpp file, put explicit instantiation to the template (with that data type
\verb!int!). Then, in other translation unit, we only need to include the header
file.
\begin{lstlisting}
// first.h
template <typename> void foo() { /* ..*/ } //definition

extern template void foo<int>(); //explicit instantiation, has global scope

// first.cpp
#include "first.h"

template void foo<int>(); //explicit instantiation

// second.cpp
#include "first.h" //repeated explicit instantiation, duplicate
int main()
{
   foo<int>();
}
\end{lstlisting}

\begin{mdframed}
The non-standard method from Microsoft VC++:
\url{http://support.microsoft.com/kb/168958}

NOTE: using \verb!export! keyword is not recommended as not many compilers
support it) \footnote{\url{http://www.parashift.com/c++-faq-lite/templates-defn-vs-decl.html}}.
Extern template is used to force the compiler not to instantiate a template when
you know that it will be instantiated somewhere else, to reduce compile time and
object file size. IMPORTANT: We use \verb!extern template!

\end{mdframed}



References:
\begin{enumerate}
  \item \url{http://www.cplusplus.com/doc/tutorial/templates/}
  \item \url{http://www.parashift.com/c++-faq-lite/templates-defn-vs-decl.html}
\end{enumerate}


\subsection{Allocators}
\label{sec:C++98_allocators}

Allocators are classes that define memory models, i.e. how much memory should
be allocated during the constructor, and how memory are allocated when a new
data element is added to the container, to be used by C++ Standard Template
Library (STL containers).

The default allocator is \verb!std::allocator!. To use a different allocator for
your container, pass a user-defined allocator class to the last (optional)
template parameter. A user-defined allocator \verb!MyAllocator!, capable of
allocating memory for an object of type $T$, should have the same members as the
default allocator
\footnote{\url{http://msdn.microsoft.com/en-us/library/aa985953.aspx}},
\begin{lstlisting}
template < class T > class MyAllocator;
\end{lstlisting}
with members functions
\begin{lstlisting}
public:
  allocator(); //constructor
  ~allocator(); //destructor
  address(); //return address
  allocate(); //allocate a block of storage, return the first
            // element of the newly allocated array large enough
            // to contain 'n objects of type 'T' 
            //NOTE: Only memory are allocated, but objects are not constructed
  deallocate(); //release a block of storage
  max_size(); // maximum size possible to allocate
  construct(); //construct an object
  destroy(); //destroy an object
  operator==();
  operator!=();
\end{lstlisting}
and implement following type definitions
\begin{verbatim}
MyAllocator::pointer
MyAllocator::const_pointer
MyAllocator::reference
MyAllocator::const_reference
MyAllocator::value_type
MyAllocator::size_type
MyAllocator::difference_type
MyAllocator::rebind
\end{verbatim}
To specify your user-defined allocator to use with a particular container, we
pass it as the second argument (the first one is the class template) to the
container.
\begin{lstlisting}
namespace std{ 
  template <class T, class Allocator = allocator<T> > class vector;
  //
  
}
\end{lstlisting}

Most experienced programmers decide to write their own allocator to avoid
performance hit. The default \verb!allocator! uses operator \verb!new! to
allocate memory (which is optimized for infrequent allocation of large memory
block). This works well if you allocate large chunks of memory (e.g. dequeue,
vector) and not frequent. However, the problem of memory fragmentation, and poor
locality reference is there.

In the case your container need to allocate memory frequent of small objects
(e.g. map, lists), it's slow when using the default allocator. A solution of
customized allocator is to use {\bf pool-based allocator}, i.e. a large
block of memory is used beforehand. \verb!Boost! libraries uses this pool-based memory
allocation. Other customized allocators are {\bf shared-based allocator}; and
{\bf garbage-collected memory allocator}.


\begin{mdframed}
An allocator is written in the way that if more memory is requested than was
reserved in the stack; it's spilled to the heap

\end{mdframed}


C++11 enhanced the using of allocators, see Sect.\ref{sec:C++11_allocators}.

References:
\begin{enumerate}
  \item \url{http://www.cplusplus.com/reference/memory/allocator/}
  \item \url{http://en.wikipedia.org/wiki/Allocator_(C++)}
  \item \url{http://www.sgi.com/tech/stl/Allocators.html}
  \item \url{http://www.drivehq.com/web/igaztanaga/allocplus/}
  \item \url{home.roadrunner.com/~hinnant/stack_alloc.html}
\end{enumerate}


\subsection{Iterators}
\label{sec:C++98_iterators}
\label{sec:iterator}


An iterator provides a homogeneous capability to operate on data elements of a
container (Sect.\ref{sec:containers}). There are different types of iterators
\begin{enumerate}
  \item input
  
  \item output
  
  \item forward
\end{enumerate}

C++ STL provides a base iterator, known as \verb!std::iterator! with 
\verb!random_access_iterator_tag! 

User can write a custom iterator class, which must be a template class, and be
parameterized by 'value type', 'pointer type', 'reference type' or all of them
(depends on implementation) - Sect.\ref{sec:iterator-user-defined}.

To traverse through data elements in a container
(Sect.\ref{sec:C++98_containers}), create an iterator pointing to a range of
data elements in that container. The most obvious form of iterator is {\it
pointer}, where a pointer can point to one element and iterate to the next one
using increment operator (++). The concept of {\bf iterator} extend this to any
container type.


Suppose we have a container
\begin{lstlisting}
std::vector<int> items;
items.push_back(1); // Append integer value '1' to vector 'items'
items.push_back(2); // Append integer value '2' to vector 'items'
items.push_back(3); // Append integer value '3' to vector 'items'
\end{lstlisting}
Now we want to traverse through each element, read and print out the value
\begin{lstlisting}
for (std::vector<int>::iterator i = items.begin(); i != items.end(); ++i) { // Iterate through 'items'
   std::cout << *i; // And print value of 'items' for current index
}
\end{lstlisting}

If we want to avoid recalculating the final \verb!v.end()!
\begin{verbatim}
for (std::vector<int>::iterator i = items.begin(); i != items.end(); ++i) { // Iterate through
std::cout << *i; // And print value of 'items' for current index
}

 //avoid recalculating the items.end
for(vector<string>::iterator it = items.begin(), end = items.end(); it != end; ++it)
{
   //...
}

for (std::vector<int>::const_iterator i = items.begin(); i != items.end(); ++i)
{ // Iterate through std::cout << *i; // And print value of 'items' for current index
}
\end{verbatim}

If we don't want to modify the data, we should use
\verb!const_iterator! instead.
\begin{lstlisting}
for (std::vector<int>::const_iterator i = items.begin(); i != items.end(); ++i)
{ // Iterate through 'items' std::cout << *i; // And print value of 'items' for current index
}
\end{lstlisting}

If we need to get to the index,
\begin{lstlisting}
// NOTE: 'auto' is available from C++11
for (auto it = v.begin(); it != v.end(); ++it) {
    // if the current index is needed:
    auto i = std::distance(v.begin(), it); 

    // access element as *it

    // any code including continue, break, return
}
\end{lstlisting}

If we want to have a stride, different from one
\begin{lstlisting}
int stride = 2;
for (auto it = v.begin(); it != v.end(); std::advance(it, stride)) {
   // ...
}
\end{lstlisting}

IMPORTANT: Always use the proper type of the iterator the same as the container
{\small \begin{verbatim}
for(std::vector<T>::iterator it = v.begin(); it != v.end(); ++it) {
    /* std::cout << *it; ... */
}
\end{verbatim}}


There are 5 different types of iterators:
\begin{enumerate}
  \item providing random access to elements
  \item providing bidirectional access (can traverse forward or backward)
  \item providing forward access (can traverse forward only)
  \item providing sequential input operations, where each value pointed by the
  iterator is read-only once and then the iterator is incremented
  \item providing sequential output operations, where each value pointed by the
  iterator is written a value only once and then the iterator is incremented
\end{enumerate} 
All of these iterators can be \verb!const! iterators, that protect the
container or its elements from being modified. An iterator is created by
deriving a subclass of \verb!std::iterators! class template. Each containers in
the C++ Standard Template Library, has a predefined iterator, say
\verb!std::vector! has the iterator is \verb!std::vector::iterator!.

To traverse, we define a range. An iterator pointing to the first element in the
container can be created using \verb!.begin()! method; and the last one is
\verb!.end()! method.

An enhancement to iterator was made in C++11 (Sect.\ref{sec:C++11_iterators}).

References:
\begin{enumerate}
  \item \url{http://www.cplusplus.com/reference/iterator/}
\end{enumerate}

\subsection{virtual function}
\label{sec:C++98_virtual-functions}

In C++, a virtual function requires the \verb!virtual! keyword.
More details is coverred in Sect.\ref{sec:virtual_member-function}.

The concept of virtual function was first added to C++ since 1983 to support
late binding (Sect.\ref{sec:late-binding}).
Another term for this is abstract method/function. This is the simple most
important part of object-oriented programming. It's important to know what is a
virtual function, how the different compilers implement it.


\subsection{\& symbol}
\label{sec:&_operator}


\section{C++03}

C++03 began at first as an TC1 (Technical Corrigendum), and then is the new
official standard ISO/IEC 14882:2003.  The difference between C++03 and C++98
are so few. C++03 does not provide any change to the core language.
Its mainly change is to extend C++ standard library, and some additional
constraints
\begin{enumerate}
  \item elements in a \verb!std::vector! must be stored contiguously, i.e. use a
  memory layout similar to an array.
  
  \item 
\end{enumerate}

\subsection{protected and static members}
\label{sec:C++03_protected-functions_static-functions}

{\bf Protected members} (constructors, functions): can only be invoked from
derived classes and a \verb!friend! class
(Sect.\ref{sec:OO_friend-class_method}). More information:
Sect.\ref{sec:OO_protected-data_method}.



{\bf Static data member}: A class can contains static member data and member
functions. When a data member is \verb!static!, a single copy of the data is
shared by all class instances (objects). It means that the \verb!static! data
members are not part of the class objects, but are separate objects. So, a
declaration of static data member inside the class is not considered a
definition, i.e. we need to define and assign initial values to the data members
outside the class definition. \textcolor{red}{IMPORTANT: We must provide the
definition of static data member in the source file (.cpp)}, not in the header
file. This will avoid linking error when the header file is included by
different source files.
\begin{verbatim}
// file1.h
class X
{
public:
      static int i;
};

// file1.cpp
#include "file1.h"

int X::i = 0; // definition outside class declaration
\end{verbatim}

Even in the source file, we cannot initialize the \verb!static! data member in
the constructor's initialization list
(Sect.\ref{sec:initialization_list}) neither.
\begin{verbatim}
class Fred {
public:
  Fred();
  ...
private:
  int i_;
  static int j_;
};

// source file
Fred::Fred()
  : i_(10)  // OK: you can (and should) initialize member data this way
  , j_(42)  // Error: you cannot initialize static member data like this
{
  ...
}
/ You must define static data members this way:
int Fred::j_ = 42;
\end{verbatim}

The special case that you can define the static data member inside the class is
when you use \verb!static const!. Indeed, the compiler will use the scalar value
\begin{verbatim}
class Fred {
public:
  static const int maximum = 42;
  ...
};
\end{verbatim}

In some cases, the definition \verb!X::i! might not contain the
\verb!=initializer! part.
\begin{verbatim}
//an implicit value (zero) wil be assigned
// int Fred::i;
\end{verbatim}
or
\begin{verbatim}
// file1.h
class Fred {
public:
  static const int maximum = 42;
  ...
};

// file1.cpp
#include "file1.h"

const int Fred::maximum;
\end{verbatim}

However, we cannot control the order of initialization of your static members,
so we need to make sure no globals and other statics refer to these objects.

{\bf Static function member}: However, \verb!static! member functions are,
unlike static member data, considered to have class scope. Like static member
data, \verb!static! member functions have external linkage.
Restrictions:\footnote{\url{http://msdn.microsoft.com/en-us/library/yyh8hetw.aspx}}
\begin{enumerate}
  \item These static member functions
have no implicit \verb!this! pointer, so it can only use \verb!static! data
members. We then must call the \verb!static! member functions using the
classname, e.g. \verb!X::count()!.
  \item \verb!virtual! cannot be used for \verb!static! member functions
  \item They cannot have the same name as non-\verb!static! functions with the
  same argument types.
\end{enumerate}

\begin{lstlisting}
class X
{
public :
	static int i; // declaration
	static int count() { return i;}
private:
    static int j; // declaration
};

int X::i = 1; // a definition must be outside the class
       // and have external linkage
int X::j = 3;
\end{lstlisting}


References:
\begin{enumerate}
  \item \url{http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12}
  \item 
\end{enumerate}
\subsection{inheritance from several classes}

\subsection{'mutable' keyword}
\label{sec:mutable_keyword}

Passing a data by constant pointer DO NOT allow any change to the data. However,
for some situations, we want to allow one data member of that class instance to
be able to change, we thus have to define that member as \verb!mutable!
\begin{lstlisting}
class Foo  
{  
private:  
    mutable bool done_;  
public:  
    void doSomething() const { ...; done_ = true; }  
};
\end{lstlisting}

\subsection{new containers: map}
\label{sec:C++03_containers}

C++03 adds a \verb!map! template in the Standard Library.

\section{C++11}
\label{sec:C++11}

Clang 3.3 and libc++ (Sect.\ref{sec:libc++}) will be the first true C++11
compiler/library. C++11 becomes the default target in GCC 5.0
(Sect.\ref{sec:GCC-5.0}).

GCC 4.8.1 was the first feature-complete implementation of the 2011 C++
standard, previously known as C++0x.


GCC 4.8.1 supports
\begin{itemize}

  \item partial C++11 if libstdc++ (Sect.\ref{sec:libstdc++}) is used

Not all new features are available in current GCC (4.8), and they are not
accepted by default. To use C++11 features, compile with \verb!-std=c++11! or
\verb!std=gnu++11!.
  
  \item full C++11 if libc++ (Sect.\ref{sec:libc++}) is used

As \verb!-std=gnu98! is still the default target, to use C++11 features, compile
with (1) \verb!-std=c++11! or \verb!std=gnu++11!; and (2) \verb!-stdlib=libc++!

\end{itemize}


\url{https://gcc.gnu.org/projects/cxx1y.html}

\subsection{atomic functions}
\label{sec:C++11_atomic}

C11 (Sect.\ref{sec:C11_atomic_op}) also support atomic operations, yet with a
different syntax than C++11. We need to use the STL header file \verb!<atomic>!

\begin{lstlisting}
#include <atomic>

std::atomic<int> counter;
\end{lstlisting}

NOTE: No compiler modification is required when using C++11 STL. However, to get
a more efficient implementation, inline assembly for each of the operation or
using some compiler support (e.g. in the form of a set of intrinsic functions).
C++11 supports any type in the template \verb!std::atomic<>!. E.g.: a class say
HugeThing contains 1MB of data, we just call
\begin{verbatim}
std::atomic<HugeThing> my_var;
\end{verbatim}

\begin{mdframed}
Portability is important, as some architecture may have limited support for
atomic operations, e.g. only support 32-bit atomics (so operation on
\verb!double! is not allowed) or only 1-bit operations (enough for light-weight
mutex).
\end{mdframed}

Example:
\begin{lstlisting}
atomic<bool> ready = false;
atomic<int> data = 0;
\end{lstlisting}
\begin{minipage}[t]{0.5\textwidth}
Thread 0:
\begin{lstlisting}
  data.store(1);
  ready.store(true);
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
Thread 1:
\begin{lstlisting}
  if (ready.load())
    assert (data.load() == 1);
\end{lstlisting}
\end{minipage}
The code is using sequential consistent model by default and memory fences are
used on X86. To remove memory fences, we can relax on writing on thread 0, and
enforce instruction reading order on thread 1, by using acquire/release model.

\begin{minipage}[t]{0.5\textwidth}
Thread 0:
\begin{lstlisting}
 data.store(1, memory_order_release);
  ready.store(true, memory_order_release);
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
Thread 1:
\begin{lstlisting}
  if (ready.load(memory_order_acquire))
    assert (data.load(memory_order_acquire) == 1);
\end{lstlisting}
\end{minipage}


RECOMMEND: Read
Sect.\ref{sec:memory_model} to understand better. 


\textcolor{red}{There's no guarantee for immediate visibility}. Atomic writes
should become visible to other threads within a 'reasonable' period of time, but
not immediate, and no precise definition of 'reasonable'. 

\verb!memory_order_seq_cst! and \verb!seq_cst! writes on atomic objects.

References: \url{http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html}

\subsection{'auto' keyword}
\label{sec:C++11_auto}

\verb!auto! help simplifying code a lot. For example, C++11 compiler can
automatically determine the type of 'y' given that
\begin{lstlisting}
int x = 5;
auto y = x;
\end{lstlisting}

The most useful usage of \verb!auto! is in template and iterator, particularly
in STL, which reduces the long declaration 
\begin{lstlisting}
map<string, string> address_book;
address_book[ "Alex" ] = "webmaster@cprogramming.com";
// add a bunch of people to address_book
\end{lstlisting}
Now, we want to iterate over the elements, so we create an iterator
\begin{verbatim}
map<string, string>::iterator itr = address_book.begin();
\end{verbatim}
which can be done using \verb!auto! and the code more readable, as \verb!itr!
will be of the same type of the value returned by \verb!address_book.begin()!
\begin{lstlisting}
auto itr = address_book.begin();
\end{lstlisting}

Example:
\begin{lstlisting}
vector<int> vec;
auto itr = vec.iterator(); // instead of vector<int>::iterator itr
\end{lstlisting}

Example: reduce the number of template passed to a function, and the way we call
the function that use template
\begin{verbatim}
template <typename BuiltType, typename Builder>
void
makeAndProcessObject (const Builder& builder)
{
    BuiltType val = builder.makeObject();
    // do stuff with val
}

...
MyObjBuilder builder;
makeAndProcessObject<MyObjBuilder>( builder );
\end{verbatim}
by using 'auto'
\begin{lstlisting}
template <typename Builder>
void
makeAndProcessObject (const Builder& builder)
{
    auto val = builder.makeObject();
    // do stuff with val
}

...
MyObjBuilder builder;
makeAndProcessObject( builder );
\end{lstlisting}



References:
\begin{enumerate}
  \item \url{http://www.cprogramming.com/c++11/what-is-c++0x.html}
  \item
  \url{http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html}
\end{enumerate}

\subsection{allocators}
\label{sec:C++11_allocators}

C++11 enhanced the allocator interface (Sect.\ref{sec:Allocator}) to allow
'scopped' allocator; so that containers of nested memory allocations, i.e. a
container whose data element is also a container. Example: a vector of string, a
map of lists

To make {\it allocator} much more useful, a keystone to the proposal was
\verb!allocator_traits! template, which contains types and static member
functions for using allocators. So any class, like \verb!Alloc!, for which
\verb!alloactor_traits<Alloc>! produces a valid instantiation with the
appropriate members defined can be used as an allocator on any standard
container (Sect.\ref{sec:C++98_containers}, .\ref{sec::C++11_containers}).




References:
\begin{enumerate}
  \item \url{http://www.cplusplus.com/reference/memory/allocator/}
\end{enumerate}

\subsection{attribute [[no return]]}
\label{sec:[[noreturn]]}

This is the C++11 feature that is equivalent to C11 (Sect.\ref{sec:_Noreturn}).
The goal is to used with dead code and to improve optimization. 


% In C++11, \verb![[no return]]! is equivalent to \verb!_Noreturn! in C11
% (Sect.\ref{sec:_Noreturn}). 

It doesn't tell the compiler that the function doesn't return a value; it just
tell the compiler that {\it control flow will not return to the caller}. It then
can dead-code eliminate any code that would otherwise follow the call, etc. In
other words, the control flow will never hit the statement after the call to
\verb!myfunc()!.

\begin{verbatim}
[[ noreturn ]] void myfunc() {

}
\end{verbatim}
then 
\begin{verbatim}
void g() {

   myfunc(); 
   
   // this is unreachable;
   std::cout<< "No written this line \n";
}
\end{verbatim}
so, the warning about the code that is unreachable can be added.


\subsection{``no exception'' specifier}

This new specifier tells the compiler whether a function will through exception
or not. It's not a compile-time check, but it is merely a method for a
programmer to inform the compiler that it can perform some optimization on the
function. Along with this C++11 feature is {\it noexception} operator:
noexception({\it expression}).

IMPORTANT: Since C++11, \verb!throw()! is deprecated, and we should use
\verb!noexcept()!.

\subsection{containers}
\label{sec::C++11_containers}
\label{sec::containers_C++11}

For a reference on older containers, see Sect.\ref{sec:C++98_containers}.

C++11 addressed a number of issues with containers
\begin{enumerate}
  \item   Initialization of STL containers with constants within the source code is not as easy as data structures inherited from C (addressed in C++11 with initializer lists).
  \item 
\end{enumerate}



\subsection{'inline namespace'}


\url{http://stackoverflow.com/questions/11016220/what-are-inline-namespaces-for}


\subsection{Iterators}
\label{sec:C++11_iterators}

Iterators was supported since C++98 (Sect.\ref{sec:C++98_iterators}). Iterators
has been made easier using \verb!auto! in C++11.
\begin{lstlisting}
//in C++11
for(auto i:items){
   std::cout << i; // And print value of 'items'
}
//
\end{lstlisting}
and implicit iterators through \verb!std::for_each!, \verb!std::copy!,
\verb!std::accumulate!. 
\begin{lstlisting}
ContainerType<ItemType> C; // Any standard container type of ItemType elements
 
void ProcessItem(const ItemType& I) { // Function that will process each item of the collection
   std::cout << I << std::endl;
}
 
std::for_each(C.begin(), C.end(), ProcessItem);  // A for-each iteration loop
\end{lstlisting}

We can also use lambda function (Sect.\ref{sec:lambda-function-C++11} -
implicitly generate function objects without defining the function explicitly)
\begin{lstlisting}
ContainerType<ItemType> C; // Any standard container type of ItemType elements
 
// A for-each iteration loop with a lambda function
std::for_each(C.begin(), C.end(), [](const ItemType& I){ std::cout << I << std::endl; });
\end{lstlisting}

or
\begin{lstlisting}
std::copy(C.begin(), C.end(), std::ostream_iterator<ItemType>(std::cout, "\n"))
\end{lstlisting}



\subsection{lambda functions (closures, function literals) C++11}
\label{sec:C++11_lambda}
\label{sec:lambda-function-C++11}


A lambda expression (lambda, shortly) is like an {\it anonymous function}, i.e.
a function with body but without name, that maintain states and local variables
that are available to the enclosing scope. This can be very useful when using
two new generic functions \verb!std::for_each! and \verb!std::transform!

{\bf Why lambda?} lambda combines the advantage of both function pointer
(Sect.\ref{sec:function_pointer}) and function object (Sect.\ref{sec:functor}).
Function pointers have the minimal syntactic overhead, but do not retain state
within a scope; while function objects have state, but require syntactic
overhead of class definition. With lambda, we can maintain state, but no need to
define class.

To use lambda, we need to include the header \verb!<algorithm>!.
Lambda expressions, also known as closures, lambda functions, function literals,
or just lambdas, have their own unique syntax.

\begin{verbatim}
GCC: 4.5. You must specify the -std=c++11 option.

Intel C++ Compiler: 11. Specify the /Qstd=c++0x option.

Microsoft Visual C++ 2010 (included in Visual Studio 2010).
\end{verbatim}

\textcolor{red}{SYNTAX}:
\begin{verbatim}

[ captures ] (parameters) -> returnTypesDeclaration { lambdaStatements; }

\end{verbatim}
\begin{enumerate}
  
  \item  \verb![ captures ]!: 
  
  The capture clause, also known as the lambda introducer, {\it specifies which
  outside variables} are (1) available for the lambda function and (2) whether they
  should be captured by value (copying) or by reference.
  
  \item \verb!( parameters )!:
  
   This is the optional parameters list, also known as the lambda declarator. 
    You can omit the parameters list if you want a function that takes zero arguments.
  

  \item  \verb!-> returnTypeDeclaration!
  
  This is the return type.
  
  Most of the time, compilers can deduce the return type of the lambda expression when you have zero or one return statement.
  
  However, if it makes it easier to understand the code, you can specify the return type. 
  
  \item \verb!{ lambdaStatements; }!: 
  
  This is the lambda body.
\end{enumerate}

\subsection{++ [capture]}

The current object (*this) can be implicitly captured if either capture default
is present. If implicitly captured, it is always captured by reference, even if
the capture default is =


\subsection{-- example 01: create a lambda and use it immediately}


Invoke immediately, no need for creating a variable.
\begin{lstlisting}
[] (int i) { std::cout << "The answer is " << i; } (42);
    //                                                 ^^^^
    //                                 Invoked immediately!
    
\end{lstlisting}

\subsection{-- example 01b: create a lambda and use it later}

The type of a lambda function (the so-called "lambda closure") is defined by the
compiler, and is a functor with a call operator whose signature is the one you
specify when defining the lambda. Therefore, you call a lambda exactly as you
would call a functor (i.e. exactly as you would call a function - or any
callable object).

Thus, if you want to assign a lambda to an object, 

\begin{enumerate}

  \item the best practice is to let the compiler deduce its type by using \verb!auto!.

  \item  std::function (this is always possible, even if the lambda is capturing): Sect.\ref{sec:std::function}
  
\begin{lstlisting}
#include <functional>

int main()
{
    std::function<void  (int)> f = [] (int i) 
                               { std::cout << "The answer is " << i; };
    f(42);
}
\end{lstlisting}
  
  \item However, we can also use function pointer for non-capturing lambdas (capturing lambdas are not convertible to function pointers)

\begin{lstlisting}
void (*f)(int) = [] (int i) { std::cout << "The answer is " << i; };
    f(42);
\end{lstlisting}


\end{enumerate}


Create a lambda function like a regular variable

\begin{lstlisting}
int main()
  {
      auto lambda = []() { cout << "Code within a lambda expression" << endl; };
      
      lambda();
  }
\end{lstlisting}


These are the same, when defining a zero argument lambda
\begin{verbatim}
auto lambda = [] { cout << Code within a lambda expression" << endl; };


auto lambda = [](void) { cout << Code within a lambda expression" << endl; };

auto lambda = [](void) -> void { cout << "Code within a lambda expression" << endl; };
\end{verbatim}

\subsection{-- example 02: lambada with pass-by-value arguments}

\begin{lstlisting}
auto sum = [](int x, int y) { return x + y; };


cout << sum(5, 2) << endl;
cout << sum(10, 5) << endl;
\end{lstlisting}

\subsection{-- example 03: using for\_each}

An excellent example of how lambda expressions can simplify code is their use with the 
\verb!std::for_each! template function.


Example: before using lambda
\begin{lstlisting}
void printnumber(int y) {
    cout << y << endl;
}

vector<int> numbers { 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 };
for_each(numbers.begin(), numbers.end(), printnumber);
    
\end{lstlisting}

Example: before using lambda, it is possible using function object (i.e. a construct that implements the \verb!operator()! operator
\begin{verbatim}
struct printnumberclass {
    void operator() (int y) { cout << y << endl; }
} printnumberobject;
 
for_each(numbers.begin(), numbers.end(), printnumberobject);
\end{verbatim}

Example: now we can use lambda
\begin{verbatim}

for_each(numbers.begin(), numbers.end(), [] (int y)
    {
        cout << y << endl;
    });
\end{verbatim}

\subsection{-- example 04: passing argument by reference}

Example:
\begin{lstlisting}
ContainerType<ItemType> C; // Any standard container type of ItemType elements
 
// A for-each iteration loop with a lambda function
std::for_each(C.begin(), C.end(), [](const ItemType& I){ std::cout << I << std::endl; });
\end{lstlisting}

Example: Use lambda to count the number of even elements in a vector
\begin{verbatim}
#include <algorithm>
#include <iostream>
#include <vector>

vector<int> v;
//push data to v


int evenCount = 0;
for_each(v.begin(), v.end(), 
     [&evenCount] (int n) {
   		cout << n;
        if (n % 2 == 0) {
          cout << " is even " << endl;
          ++evenCount;
   	    } else {
          cout << " is odd " << endl;
        }
        cout << "There are " << evenCount 
          << " even numbers in the vector." << endl;
    }      
);
\end{verbatim}
As you can see \verb![&evenCount]! represent the lambda, \verb!(int n)! is the
parameter list, and the remaining part between \verb!{  }! is the body.

This can be done using function
object.\footnote{\url{http://msdn.microsoft.com/en-us/library/vstudio/dd293608.aspx}}
\begin{lstlisting}
class FunctorClass
{
public:
    // The required constructor for this example.
    explicit FunctorClass(int& evenCount) 
        : m_evenCount(evenCount)
    {
    }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const
    {
        cout << n;

        if (n % 2 == 0) {
            cout << " is even " << endl;
            ++m_evenCount;
        } else {
            cout << " is odd " << endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    FunctorClass& operator=(const FunctorClass&);

    int& m_evenCount; // the number of even variables in the vector.
};
\end{lstlisting}
then we use
\begin{verbatim}
int evenCount = 0;
for_each(v.begin(), v.end(), FunctorClass(evenCount));

// Print the count of even numbers to the console.
cout << "There are " << evenCount 
     << " even numbers in the vector." << endl;
\end{verbatim}

\subsection{-- example 05: using variables declared from outside, by value}


Example: the variable name (divisor) that you want to capture by value within
the lambda capture clause.

\begin{lstlisting}
int main()
{
    // The user would introduce different values for divisor    
    int divisor = 3;
    vector<int> numbers { 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 };
    
    for_each(numbers.begin(), numbers.end(), [divisor] (int y)
    {
        if (y % divisor == 0)
        {
            cout << y << endl;
        }
    });
}
\end{lstlisting}


IMPORTANT: By using the \verb![=]! capture option, which captures any referenced
variable within the lambda by value (making a copy). This option captures only
the outside variables referenced within the lambda body

You can use  \verb!=! as a default option (i.e. capture all variables (and by
value) combined with the exceptions, i.e. those should be captured by reference,
e.g. \verb![=, &sum, &division, &multiplication]!

\begin{lstlisting}

for_each(numbers.begin(), numbers.end(), [=] (int y)
{
    if (y % divisor == 0)
    {
        cout << y << endl;
    }
});
\end{lstlisting}

\subsection{-- example 05b: using varibles declared from outside, by reference}

The lambda captures divisor by value and sum by reference because sum has an
ampersand (\&) prefix

\begin{lstlisting}

int main()
{
    int sum = 0;
    int divisor = 3;
    vector<int> numbers { 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 };
    
    for_each(numbers.begin(), numbers.end(), [divisor, &sum] (int y)
    {
        if (y % divisor == 0)
        {
            cout << y << endl;
            sum += y;
        }
    });
 
    cout << sum << endl;
}
\end{lstlisting}

SPECIAL CASE: You can use either = or \& as a default option combined with the exceptions.
\begin{enumerate}
  
  \item \verb![=, &sum]!: Captures any referenced variable within the lambda by value (making a copy), except sum that has to be captured by reference.
  
  
  \item \verb![&, divisor]!: Captures any referenced variable within the lambda by reference, except divisor that has to be captured by value.
\end{enumerate}


\subsection{-- example 05c: capture the enclosing class}

If the lambda is defined inside a class, we can pass \verb!this! so that all data members of the class's object is available,
i.e. \verb![this]!.

NOTE: \verb![this]! because it allows you to capture the this pointer of the enclosing class.
 
\begin{verbatim}
class SomeA
{

  void doSomething()
  {
    
    for_each(numbers.begin(), numbers.end(), [this, divisor] (int y)
    {
        if (y % divisor == 0)
        {
            cout << y << endl;
        }
    });
  
  }

}
\end{verbatim}


\subsection{-- example 06: multi-threading}

To use lambda in multi-threading at high-level 
\begin{verbatim}
std::async([] {...})  //try to perform ... asynchornously
\end{verbatim}

\subsection{-- How lambda function works, and how to improve it with std::function}
\label{sec:std::function}

Each time you are creating a lambda expression, its implementation creates a new
class under the hood. Thus, each lambda creates a separate class and has a
different type.

So, even when many lambda expressions receive the same arguments and return the
same type, each of them will be a different class; that is, a different type


Luckily, C++11 incorporates a wrapper for any of the following functions with
\verb!std::function! and makes it easy to pass around lambda expressions:

Example: we define a type, that represents all functions that 
(1) accept 1 argument of type \verb!int!, and (2) returns \verb!void!.


\begin{lstlisting}


void run_within_for_each(std::function<void (int)> func)
{
    vector<int> numbers{ 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 };
 
    for_each(numbers.begin(), numbers.end(), func);
}
 
 
 
    auto func1 = [](int y)
    {
        cout << y << endl;
    };
 
    auto func2 = [](int z)
    {
        cout << z * 2 << endl;
    };
 
    run_within_for_each(func1);
    run_within_for_each(func2);
    
    
\end{lstlisting}


Example: a function that (1) accept 2 arguments by value of type \verb!int!,
and (2) returns a boolean value.

\begin{verbatim}
std::function<bool (int, int)>.
\end{verbatim}

Example: write a function, that each time called, return a function object of the function 
that (1) accept a single argument of type \verb!int! by value, and (2) returns a boolean value

\begin{lstlisting}

std::function<bool(int)> create_function()
{
    return [](int x)
    {
        return (x < 100);
    };
}
\end{lstlisting}

References:
\begin{enumerate}
  \item \url{http://www.cprogramming.com/c++11/c++11-lambda-closures.html}
\end{enumerate}

\subsection{regular expression}


\subsection{memory barrier (multi-threading)}

C memory model is quite weak in terms of ordering constraints. 'volatile' is a
way to enforce a constraint on a particular variable. However, it's not of good
use in multi-threading. Go back to the example in Sect.\ref{sec:volatile_C}. 
\begin{lstlisting}
volatile int a;
a = 1
b = 4
a = 5
\end{lstlisting}
With 'volatile', two other scenarios can happen without violating 'volatile'
rule

\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
a = 1;
a = 5;
b = 4;
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\begin{lstlisting}
b = 4;
a = 1;
a = 5;
\end{lstlisting}
\end{minipage}

This isn't enough for multi-threading, where the order of every write is
important. 


References:
\begin{enumerate}
  \item \url{http://www.informit.com/articles/article.aspx?p=1832575&seqNum=3}
\end{enumerate}

\subsection{smart pointers}
\label{sec:c++11_smart_pointer}

It's important to avoid memory leakage where a dynamically allocated memory is
not free after use. Other than that, we also want to avoid dangling pointers,
allocation failures, etc. That's why smart pointers were developed, i.e. to
handle automatic destroy when out of scope. Also, a smart
pointer needs to have the same interface as pointers, i.e. dereferencing (operator *),
indirection (operator \verb!->!), and about the same performance. A detailed
discussion is given in Sect.\ref{sec:smart_pointer}.

\subsection{move-only objects}


C++11 provide a way to define a unique object called {\bf move-only objects},
i.e. the object cannot be copied, but can only be moved. We only use move-only
objects for thoses with short-term life. We use \verb!const unique_ptr! template
(Sect.\ref{sec:unique_ptr}).
Simply put, this is a magic bullet for dynamically created objects.

% The only location it can be is on the stack, and making it a member of a class is
% IMPOSSIBLE (or giving undefined behavior).
% 
% \begin{verbatim}
% const std::unique_ptr<T> myFunc();
% \end{verbatim}
% As we cannot call \verb!std::move! on a \verb!const! object, we need to use
% either \verb!const&! or \verb!const&&!.
% 
% \begin{verbatim}
% const std::unique_ptr<T> &ptr = myFunc();
% \end{verbatim}
% 


\subsection{hash tables}

\subsection{random  number generators}

C++11 introduces \verb!<random>! header file (Sect.\ref{sec:C++11_random}).

\subsection{STL (standard threading library)}

\subsection{new 'for loops'}

\subsection{new container classes}
\label{sec:C++11_containers}


\subsection{new macros}

'variadic' macro (Sect.\ref{sec:macro_variadic}) is a part of the standard in
C++11.


\subsection{raw string literal (verbatim string literal)}
\label{sec:raw-string-literal}
Markup languages like HTML, XML use a lot of quotation marks (``) and new lines.
To use them in the regular literal string, we need to use escape character
(backslash \verb!\!). This is irritating, cumbersome and error prone. 

Languages like Perl, Python, and Lua have addressed these issues by introducing
{\bf raw string literal}, which is simply a string literal that doesn't
recognize C++ escape sequences. 

A verbatim string is one that does not need to be escaped.
This feature is not available in C++ until C++11 standard -
Sect.\ref{sec:raw_string_literal-C++11}.


\subsection{variadic templates (C++11) or template parameter pack for variadic function}
\label{sec:variadic-template}
\label{sec:template-arbitrary-number-of-arguments}
\label{sec:parameter-pack}

C provides the capability to write a function that can accept any number of
arguments (Sect.\ref{sec:variadic_function}).

Prior to C++11, , the only way to write functions that take an arbitrary number
of arguments was to use variadic functions like in C.

Since C++11, we can do that via template approach (aka variadic templates).
It's a way to write functions that take an arbitrary number of arguments in a
type-safe way and have all the argument handling logic resolved at compile-time,
rather than run-time.


\begin{verbatim}
template <typename... Ts>  // (1)
void ignore(Ts... ts) {}   // (2)
\end{verbatim}

to declare Ts as a so-called {\bf template parameter pack}. Which means
depending upon how many arguments are passed in at the time of using it, the
compiler will create a new proper method - at compile-time - with the same
number of arguments and proper types.

\url{https://en.cppreference.com/w/cpp/language/parameter_pack}


\url{https://eli.thegreenplace.net/2014/variadic-templates-in-c/}

\subsection{control template instantiation}
\label{sec:SFINAE-C++11}


Sect.\ref{sec:type_trait} provides function to test a given type, now we can use
this to determine whether a template instantiation is allowed or not; or it
allows us to provide different implementations of the foo class depending on the
template arguments it is instantiated with.


NOTE: \verb!std::enable_if! to force instantiation to succeed only for the
appropriate template arguments.
This relies on Substitution Failure Is Not An Error (SFINAE) - Sect.\ref{sec:SFINAE}.
 

\begin{verbatim}
#include <type_traits>

template <typename T, typename Enable = void>
class foo;

// The template here will only be instantiated when T is an integral type.
template <typename T>
class foo<T, typename std::enable_if<std::is_integral<T>::value>::type>
{ };

// The template here will only be instantiated when T is a floating point type.
template <typename T>
class foo<T, typename std::enable_if<std::is_floating_point<T>::value>::type>
{ };

\end{verbatim}

If you want to simply prevent a template from being instantiated for certain template arguments, consider using 
\verb!static_assert! instead.

\url{https://cpppatterns.com/patterns/class-template-sfinae.html}

\subsection{union and array initialization lists}


\subsection{new qualifiers (e.g. final, override, default)}
\label{sec:C++11_final-override-default-delete}
\label{sec:C++11-delete}

\verb!final! is the keyword that tell a class or a method is uninheratable.
(Sect.\ref{sec:OO_uninheritable-class}).

\verb!override! helps detecting error easier when writing \verb!virtual!
function (Sect.\ref{sec:virtual_member-function}). This allows us to avoid using
overrriding from overloading.

Any C++ compiler automatically add default constructor, copy constructor, copy
assignment operator (=) and a destructor, only if they are not defined in a
class. To enforce the compiler to create the default ones, even if an alternate
versions have been implemented by the programmer, we can use the C++11
\verb!default! keyword.

\begin{Verbatim}
class Foo
{
    Foo(int x); // Custom constructor
    Foo() = default; // The compiler will now provide a default constructor for class Foo as well
};
\end{Verbatim}

Using \verb!delete! keyword is useful, which explicitly disallow a function from
being defined or called. 
\begin{enumerate}
  \item  An example is to make the class uncopyable.
\begin{Verbatim}
class Foo
{
    Foo& operator=(const Foo&) = delete; // disallow use of assignment operator
    Foo(const Foo&) = delete; // disallow copy construction
    
};
\end{Verbatim}
Here, we cannot do
\begin{verbatim}
Foo a, b;

a = b; // ERROR
\end{verbatim}
  
  \item avoid some function from being defined. When we can pass a variable of
  type \verb!short, int!, it is automatically converted to \verb!long!
  (Sect.\ref{sec:type-cast-C}). But as we cannot pass \verb!long! type; it makes
  nothing other than \verb!long long! is accepted.
  
\begin{Verbatim}
class Foo
{
    void Foo(long long); // Can create Foo() with a long long
    void Foo(long) = delete; // But can't create it with anything smaller
};
\end{Verbatim}

   \item A solution to avoid implicit conversion is by using template function
\begin{Verbatim}
class Foo
{
    void Foo(long long); // Can create Foo() with a long long
    template<typename T> void Foo(T) = delete; // But can't create it with anything else
};
\end{Verbatim}

\end{enumerate}

\url{http://www.learncpp.com/cpp-tutorial/b-6-new-virtual-function-controls-override-final-default-and-delete/}

\section{C++14}
\label{sec:C++14}

C++14 mainly contains technical fixes and tweaks to the current C++11 standard
(Sect.\ref{sec:C++11}). As the released date is not necessary 2014, C++14 is aka
C++1y.  

C++14 is the default since GCC 6.1
\url{https://gcc.gnu.org/projects/cxx-status.html#cxx14}

CUDA 9, the nvcc compiler adds support for C++14 with \verb!auto! keyword and lambda expressions.
 


New features are supported first in C++1y in the GCC 4.8 and later.
either \verb!-std=gnu++1y! or \verb!-std=c++14!. NOTE: Deprecated option
\begin{verbatim}
-std=gnu++1y     //deprecated
\end{verbatim}
which is GNU dialect of \verb!-std=c++14!.
\url{https://gcc.gnu.org/projects/cxx1y.html}


New features
\begin{enumerate}
  \item a class template that simulates {\it dynamics array}.
  \item runtime-sized arrays with automatic storage duration
\end{enumerate}
The two new features provide mechanisms for creating array-like objects and
arrays whose sized are determined at runtime, very much like C99's {\it
variable length array} (VLA). 




\url{https://en.wikipedia.org/wiki/C++14}
\section{C++1z}
\label{sec:C++1z}

"C++1z" is the name refers to the future release of C++ standard (probably to be
C++17).

\section{C++20}


Class templates, function templates, and non-template functions (typically
members of class templates) may be associated with a \verb!constraint!
(Sect.\ref{sec:constraint-C++20}), which specifies the requirements on template
arguments, which can be used to select the most appropriate function overloads
and template specializations.

\url{https://en.cppreference.com/w/cpp/language/constraints}


\subsection{Detection idioms}

\begin{verbatim}
#include <experimental/type_traits>

std::experimental::is_detected, 

std::experimental::detected_t, 

std::experimental::detected_or

\end{verbatim}
\url{https://en.cppreference.com/w/cpp/experimental/is_detected}

\subsection{Concepts}
\label{sec:concept-C++20}

Concepts is a proposed C++ feature which allows succinct, expressive, and powerful constraining of templates.
It was rejected for C++11; and will be merged into C++20. 

Check GCC compiler to support this by checking
\begin{verbatim}
__cpp_concepts 201507
\end{verbatim}

Two new keywords: concept and requires

The concept specifier shall be applied only to the definition of a function
template or variable template, declared in namespace scope.

\begin{itemize}

  \item A function template definition having the concept specifier is called a function concept.
Also, the function is treated as \verb!noexcept(true)! is used as well.

\begin{verbatim}
// OK: declares a function concept

template<typename T>
    concept bool F1() { return true; }
    
    //error as you redeclare a function concept
    // i.e. same prototype with the previous one
template<typename T>
    concept bool F3() { return true; }
\end{verbatim}


  \item   A variable template definition having the concept specifier is called a variable concept.
  
\begin{verbatim}
// OK: declares a variable concept

template<typename T>
    concept bool V1 = true;
    
//error: NOT allow in class scope
struct S {
    template<typename T>
      static concept bool C = true;
}
\end{verbatim}

A concept definition shall not be declared with the \verb!thread_local!, inline, friend, or constexpr specifiers.
\end{itemize}

The requires keyword is used to begin a requires-expression, which is a prvalue
expression of type bool that describes the constraints on some template
arguments. Such an expression is true if the constraints are satisfied, and
false otherwise:

\begin{verbatim}

void f(int) requires false;

f(0); // error: cannot call f
void (*p1)(int) = f; // error: cannot take the address of f 

decltype(f)* p2 = nullptr; // error: the type decltype(f) is invalid
\end{verbatim}

Concepts provides new syntactic forms and modifications to existing language
semantics that enables the specification and checking of constraints on template
arguments, and the ability to overload functions and specialize class templates
based on those constraints

\begin{enumerate}
  \item a function can have constraints
\end{enumerate}

\url{https://blog.tartanllama.xyz/detection-idiom/}

\subsection{using auto:: and C:: to simlified type declaration}

We can use \verb!C::! as a placeholder type if we define the concept for it.

\begin{verbatim}
template<typename T> concept bool C = sizeof(T) == sizeof(int);

template<int N> concept bool D = true;


struct S1 { int n; };
struct S2 { char c; };
struct S3 { struct X { using Y = int; }; };

int auto::* p1 = &S1::n; // auto deduced as S1

int D::* p2 = &S1::n; // error: D does not designate a placeholder type

int C::* p3 = &S1::n; // OK: C deduced as S1

char C::* p4 = &S2::c; // error: deduction fails because constraints are not satisfied
\end{verbatim}


\begin{verbatim}
struct S3 { struct X { using Y = int; }; };

void f(typename auto::X::Y);


f<S3>(0); // OK
\end{verbatim}
In the declaration of f, it can be replaced later through the explicit specification of template arguments.

\section{C++ Standard Library}
\label{sec:C++_Standard_Library}

Similar to C standard library (Sect.\ref{sec:C-standard-library}), {\bf C++
Standard Library} is a collection of classes and functions, part of the ISO C++
Standard, which are organized into corresponding header files
\begin{enumerate}
  \item C++98: <bitset> (a bit array), <deque> (double-ended queue, i.e.
  elements can be added or removed from either end of the que), <list>
  (\verb!std::list! doubly-linked list), <map> (\verb!std::map>!, a map is a
  hash (or associative array) with a data element is a (key,value) pair, and
  \verb!std::multimap! where a key may associate with multiple values),
  <queue> (\verb!std:queue! a single-ended queue, and \verb!std::priority_queue!
  priority queue where each element has an associated priority-value and  
  serving elements are based on the priority-value first), <set>
  (\verb!std::set! and \verb!std::multiset!), <stack>  
  
  \item C++03:
  
  \item C++11: <array> (\verb!std::array! fixed-sized array),
  \verb!<forward_list>! (\verb!std::forward_list! a singly-linked list),
  \verb!<unordered_map>! (\verb!std::unordered_map! and
  \verb!std::unordered_multimap! unordered hash-tables), \verb!<unordered_set>!
  (\verb!std::unordered_set! and \verb!std::unordered_multiset!), <vector> (a
  dynamic-sized array)
\end{enumerate}

Totally, C++98 Standard Library has 32 C++ header files. C++03 has 33 C++ header
files (new: <ostream> that defines types and several functions to control output
to a stream buffer). C++11 has total 52 C++ header files.

C++98/C++03 Standard Library incorporates 18 header-files from C Standard
Library, ending with '.h'; while C++11 Standard Library incorporates 26 C header
files (Sect.\ref{sec:C-standard-library}). However, these header-file should not
be used, as they put all functions in the global namespace. Instead, we should
use the equivalent header files, yet defined for C++ Standard Library, which
allows all functions to be used in the namespace \verb!std! or can also in the
global namespace. The header files in C++ don't have the '.h' extension, and
start with \verb!<c...>!, e.g.
\verb!<cstdlib>!.

A major part of C++ standard library is several generic containers
\begin{itemize}
  \item C++98 containers: (Sec.\ref{sec:C++98_containers})
  \item C++03 containers: 
  \item C++11 containers: Sect.\ref{sec:C++11_containers}
\end{itemize}
, and functions to utilize/manipulate these
containers. They belong to the so-called C++ Standard Template Library, which
inherits many features from STL, a library developed by Alexander Stepanov.
NOTE: linked list allows inserting or removing at any nodes without reorganizing
or reallocation the array: singly-linked list (traverse only in one direction,
i.e. each node has 2 fiels: data and address to next-node), double-linked list
(traverse in both directions, i.e. each node has 3 fields:
data, address to previous-node and address to next-node), and other types of
linked list not porpular use. List of C++ template libraries:
\url{http://en.wikipedia.org/wiki/List_of_C++_template_libraries}


The Microsoft implementation of C++ standard library is called C++ Runtime Library (C++RT) (Sect.\ref{sec:C++_RT}).

A good source of programming tips using C++ STL is
\begin{itemize}
  \item \url{http://www.sgi.com/tech/stl/}
\end{itemize}
% 
% In addition, C++98 Standard Library also support 18 C header files. C++03
% support \ldots; and C++11 supports 26 C header files.

\section{Checking version of C/C++ specification}
\label{sec:check-language-support}

We can use \verb!__cplusplus! macro (Sect.\ref{sec:__cplusplus}).

%\section{Mixing C and C++ code}
\section{extern ``C'': mixing C++ with C code}
\label{sec:extern_''C''}

Name mangling (or name decoration) is a widely used technique by the compiler to
enable function overloading (Sect.\ref{sec:name_mangling}). 

\subsection{Mixing C++ code with C code}

IMPORTANT: It's not a good idea to mix C code and C++ code in the same files
\footnote{\url{http://www.cs.technion.ac.il/users/yechiel/c++-faq/overview-mixing-langs.html}}.
However, if your program has multiple source files, some are C code, some are
C++ codes, we need to either (1) compile everything with C++ compiler (which
may leads to some errors when compiling C code with C++ compiler and you need to
modify them), or (2)
\begin{enumerate}
  \item Use C compiler and C++ compiler from the same vendor, with compatible
  versions.
  \item Use C++ compiler for \verb!main()!
  \item Use direct linking 
\end{enumerate}
It's suggested to use the first option, as you had the chance to make the code
better.

\subsection{Calling C code from C++}
\label{sec:C-code-callable-from-C-and-C++}

Suppose you have a library written in C, with the header files.
Now, you want to use the API of this library from C++ code, 
make sure you put the \verb!#include! with this library header file
inside the \verb!extern "C"! scope.

Example:
\begin{verbatim}
// This is C++ code

extern "C" {
  // Get declaration for f(int i, char c, float x)
  #include "my-C-code.h"
}

int main()
{
  f(7, 'x', 3.14);   // Note: nothing unusual in the call
  ...
}
\end{verbatim}
This is important if you want to include a non-standard C-style header into your
C++ code.

A better solution is to put this into each C-style header file
(Sect.\ref{sec:__cplusplus})
\begin{verbatim}
#ifdef __cplusplus
extern "C" {
#endif

// C code

#ifdef __cplusplus
}
#endif

\end{verbatim}

\textcolor{red}{Example}: A better approach is to check \verb!__cplusplus!
macro, where we need to use \verb!extern "C"! one time.
\begin{lstlisting}
// in the header file

#include <..>
#include "..."

#ifdef __cplusplus 
extern "C" {
#endif

    /* typedef, variables, function prototype */
    /* of C-code libraries here */
    
#ifdef __cplusplus
}
#endif
\end{lstlisting}
So, all header files refer to codes written in C and compiled by C compiler
(e.g. string.h), should be wrapped by
\begin{lstlisting}
#ifdef __cplusplus
extern "C" {
#endif
 
void *memset (void *, int, size_t);
char *strcat (char *, const char *);
int   strcmp (const char *, const char *);
char *strcpy (char *, const char *);
 
#ifdef __cplusplus
}
#endif
\end{lstlisting}

Then, we can include the non-standard C-style header normally
into C++ code
\begin{verbatim}
// This is C++ code

// Get declaration for f(int i, char c, float x)
#include "my-C-code.h"   // Note: nothing unusual in #include line

int main()
{
  f(7, 'x', 3.14);       // Note: nothing unusual in the call
  ...
}
\end{verbatim}
\footnote{\url{http://www.cs.technion.ac.il/users/yechiel/c++-faq/include-c-hdrs-personal.html}}


\subsection{Make C++ codes callable to both C and C++ }
\label{sec:C++-code-callable-from-C-and-C++}

\url{http://stackoverflow.com/questions/1025345/extern-c-can-not-be-used-at-class-level}

There are different scenarios when calling a C++ compiled code from C code
\begin{itemize}
  \item C++ function
  \item C++ class object
  \item C++ class method
\end{itemize}
Then you may want to disable name mangling in the C++ code
(Sect.\ref{sec:name-mangling}), so that C code can read it easily. 
% Suppose you have a C++ code, and you want the code to be callable from both C++
% and C. To make C++ codes callable from C code, we use 
\begin{verbatim}
extern "C"
\end{verbatim}
facility to wrap the C++ code, which tells the C++ compiler to compile that bit
of code without name mangling (Sect.\ref{sec:name_mangling}). 
This doesn't affect how the code is compiled; but how the code is linked. Code
inside \verb!extern ``C''!, if C++, is still C++ code. 


\textcolor{red}{Example}: OPTION 1 - add direct to the function
\begin{verbatim}
#include "netlib.h"
#include "netlib_implementation.h"
extern "C" netSHandle netOpenSendSocket( ... )
{
  t_libSendSocket *s = malloc(...);
  ...
  return s;
}
extern "C" netRHandle netOpenSReceiveSocket( ... )
{
  t_libReceiveSocket *s = malloc(...);
  ...
  return s;
}
\end{verbatim}

Example:
\begin{verbatim}
#ifdef __cplusplus
extern ''C''
{
#endif

//add C++ code here

#ifdef __cplusplus
}
#endif
\end{verbatim}
However, this reason doesn't make much sense as there are features cannot be
used in C, like classes and namespaces. Never mixed \verb!extern ``C''! with
\verb!namespace!.

\url{http://www.parashift.com/c++-faq-lite/cpp-objs-passed-to-c.html}



%IMPORTANT: Using
% \begin{verbatim}
% #ifdef __cplusplus
% extern "C" {
% #endif
% 
% // put the code here
% 
% 
% #ifdef __cplusplus
% }
% #endif
% \end{verbatim}

However, we cannot define any symbol that cannot be built with C linkage (i.e.
no class, no template).

\url{http://www.oracle.com/technetwork/articles/servers-storage-dev/mixingcandcpluspluscode-305840.html}


% In C++, name mangling is the feature that C++ compiler allows function
% overloading feature (Sect.\ref{sec:name_mangling})


% So, if you want the prototype in the header file to refer to C symbol names,
% even when being compiled with a C++ compiler, then put them inside 
% \verb!extern ``C''! with \verb!__cplusplus! as below.



\section{Comments in C vs. C++}

From C95 and earlier, the only comment syntax is the multiline syntax
\begin{verbatim}
/*   something here
    here
*/
\end{verbatim}
Since C99, one-line comment is supported.


In C++, a single line and multiple line is supported.
\begin{verbatim}
int i = 0; //  single line

/* multiple 
    line
*/
\end{verbatim}

\section{lvalue and rvalue}
\label{sec:lvalue}
\label{sec:rvalue}

We often see the term lvalue or rvalue at compile-time error message.


\begin{enumerate}
  
  \item  An \verb!lvalue! (locator value) represents an object that occupies some
  identifiable location in memory (i.e. has an address).


Initially when lvalues were defined for C, it literally meant "values suitable
for left-hand-side of assignment", i.e. on the left side of \verb!=! operator.
However, when ISO C added the \verb!const! keyword, this definition had to be
refined.

\begin{lstlisting}
const int a = 10; // 'a' is an lvalue
a = 10;           // but it can't be assigned!
\end{lstlisting}

Those that can are called modifiable lvalues. Formally, the C99 standard defines modifiable lvalues as:

% Remember that in an assignment statement, the left-side of
% the \verb!=! operator must be a lvalue specifier.

  \item \verb!rvalues! are defined by exclusion, by saying that every expression is
  either an lvalue or an rvalue. 
  
  Therefore, from the above definition of lvalue, an rvalue is an expression
  that does not represent an object occupying some identifiable location in
  memory.
  
\end{enumerate}
\begin{verbatim}
lvalue  =  expression(lvalue, rvalue);
\end{verbatim}

Example 00:
\begin{lstlisting}
4 = var;       // ERROR!
(var + 1) = 4; // ERROR!
\end{lstlisting}
Neither the constant 4, nor the expression var + 1 are lvalues (which makes them rvalues)


Example 01:
\begin{verbatim}
int foo() {return 2;}

int main()
{
    foo() = 2;

    return 0;
}

test.c: In function 'main':
test.c:8:5: error: lvalue required as left operand of assignment
\end{verbatim}

Example 02:
\begin{verbatim}
int& foo()
{
    return 2;
}


testcpp.cpp: In function 'int& foo()':
testcpp.cpp:5:12: error: invalid initialization of non-const reference
of type 'int&' from an rvalue of type 'int'
\end{verbatim}
\url{https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/}

\subsection{modifiable rvalue}


Initially when lvalues were defined for C, it literally meant "values suitable
for left-hand-side of assignment". Later, however, when ISO C added the const
keyword, this definition had to be refined.

Those that can are called modifiable lvalues. Formally, the C99 standard defines
modifiable lvalues as:
\begin{verbatim}

[...] an lvalue that does not have array type, does not have an incomplete type,
does not have a const-qualified type, and if it is a structure or union, does
not have any member (including, recursively, any member or element of all
contained aggregates or unions) with a const-qualified type.

\end{verbatim}

\subsection{conversion from lvalue to rvalue}

language constructs operating on object values require rvalues as arguments.
Example: binary addition operator '+' takes two rvalues as arguments and returns an rvalue:

\begin{lstlisting}
int a = 1;     // a is an lvalue
int b = 2;     // b is an lvalue
int c = a + b; // + needs rvalues, so a and b are converted to rvalues
               // and an rvalue is returned
\end{lstlisting}

An implicit lvalue-to-rvalue conversion. All lvalues that aren't arrays,
functions or of incomplete types can be converted thus to rvalues.

What is this "cv-unqualified" thing? CV-qualifier is a term used to describe
\verb!const! and \verb!volatile! type qualifiers.

\begin{verbatim}

An lvalue (3.10) of a non-function, non-array type T can be converted to an
rvalue. [...] If T is a non-class type, the type of the rvalue is the
cv-unqualified version of T. Otherwise, the type of the rvalue is T.

Each type which is a cv-unqualified complete or incomplete object type or is
void (3.9) has three corresponding cv-qualified versions of its type: a
const-qualified version, a volatile-qualified version, and a
const-volatile-qualified version. [...] The cv-qualified or cv-unqualified
versions of a type are distinct types; however, they shall have the same
representation and alignment requirements (3.9)

\end{verbatim}
 
Question:
What about the other direction? Can rvalues be converted to lvalues? Of course
not! This would violate the very nature of an lvalue according to its definition

\begin{verbatim}
int arr[] = {1, 2};
int* p = &arr[0];
*(p + 1) = 10;   // OK: p + 1 is an rvalue, but *(p + 1) is an lvalue

\end{verbatim}

Example:  the unary address-of operator \verb!'&'! takes an lvalue argument and produces an rvalue:
\begin{verbatim}
int var = 10;
int* bad_addr = &(var + 1); // ERROR: lvalue required as unary '&' operand
int* addr = &var;           // OK: var is an lvalue
&var = 40;                  // ERROR: lvalue required as left operand
                            // of assignment
\end{verbatim}

\subsection{lvalue reference (C++)}

The ampersand plays another role in C++ - it allows to define reference types.
\begin{lstlisting}
std::string& sref = std::string();  // ERROR: invalid initialization of
                                    // non-const reference of type
                                    // 'std::string&' from an rvalue of
                                    // type 'std::string'
\end{lstlisting}

This makes possible the very common C++ idiom of accepting values by constant
references into functions, which avoids unnecessary copying and construction of
temporary objects.

\subsection{rvalue in C}

In C, rvalues never have cv-qualified types. Only lvalues do. 


\subsection{rvalue in C++ (support cv-qualified rvalue)}

In C++, on the other hand, class rvalues can have cv-qualified types, but
built-in types (like int) can't.


Example: we can have two methods exactly the same name, same argument, except one is \verb!const!. So, when creating an object, 
e.g. \verb!cbar()!,
if the object is created using \verb!const!, and all \verb!const! version of the method(s) must be used,
\begin{verbatim}
#include <iostream>

class A {
public:
    void foo() const { std::cout << "A::foo() const\n"; }
    void foo() { std::cout << "A::foo()\n"; }
};

A bar() { return A(); }
const A cbar() { return A(); }


int main()
{
    bar().foo();  // calls foo
    cbar().foo(); // calls foo const
}
\end{verbatim}

The second call in main actually calls the foo () const method of A, because the
type returned by cbar is const A.  Note also that the return value from cbar is
an rvalue. So this is an example of a cv-qualified rvalue in action.

 

\subsection{rvalue reference (C++11)}
\label{sec:rvalue-reference-C++11}


Rvalue references and the related concept of move semantics is one of the most powerful new features the C++11.

In early C++, one of the main differences between lvalues and rvalues is that lvalues can be modified, and rvalues can't. 
Since C++11, this is no longer correct.

C++11 adds a crucial twist to this distinction, by allowing us to have
references to rvalues and thus modify them, in some special circumstances.

Consider this example:
\begin{verbatim}
cout << "assigning rvalue...\n";
v2 = Intvec(33);
cout << "ended assigning rvalue...\n";
\end{verbatim}
In earlier C++ version, these are the steps
\begin{verbatim}
assigning rvalue...
[0x28ff08] constructor			//Intvec(33)
[0x28fef8] copy assignment operator
[0x28fec8] copy constructor
[0x28fec8] destructor			//Intvec(33);
[0x28ff08] destructor
ended assigning rvalue...
\end{verbatim}

The copy assignment operator
\begin{lstlisting}
class Intvec
{
    Intvec& operator=(const Intvec& other)
    {
        log("copy assignment operator");
        Intvec tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_data, tmp.m_data);
        return *this;
    }
  private:
    size_t m_size;
    int* m_data;
};   
}
\end{lstlisting}

As you can see, there is a creation of a temporary variable \verb!tmp!. Since
C++11, the two redundant constructor/destructor inside the copy assignment can
be prevented.
C++11 gives us rvalue references with which we can implement "move semantics",
and in particular a "move assignment operator".
The \verb!&&! syntax is the new rvalue reference. It does exactly what it sounds
it does - gives us a reference to an rvalue, which is going to be destroyed
after the call. We can use this fact to just "steal" the internals of the rvalue

\begin{lstlisting}
Intvec& operator=(Intvec&& other)
{
    log("move assignment operator");
    std::swap(m_size, other.m_size);
    std::swap(m_data, other.m_data);
    return *this;
}
\end{lstlisting}


\url{https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/}


\section{Scope in C: block scope, file scope and program scope}
\label{sec:scopes_in_C}

There are three levels of identifier's scope in C.
\begin{itemize}
  \item program scope
  \item file scope
  \item block scope
\end{itemize}
By default, an identifier has program scope, and thus can be accessed from any
where from the same program, regardless in which file the identifier is
defined, under the condition of using \verb!extern! specifier in the files you
want to use it. In other words, \textcolor{red}{only non-static identifier can
be accessed from a different file B if in this file B, it is also declared with
the same signature using 'extern' specifier} (see below).

C99 STANDARD: 
\begin{verbatim}
C99 (6.2.2/3) If the declaration of a file scope identifier 
for an object or a function contains the storage class 
specifier static, the identifier has internal linkage

C99 (6.2.2/5) If the declaration of an identifier for an object has file scope
and no storage-class specifier, its linkage is external.
\end{verbatim}

Example: \verb!x! has external linkage, while \verb!y,z! have internal linkage.
\begin{verbatim}
int x = 0;             // **program scope**   
static int y = 0;      // **file scope**  
static float z = 0.0;  // **file scope** 

int main()  
{  
   int i;   /* block scope */  
   /* .
      .
      .
   */ 
   return 0;  
}  
\end{verbatim}
The \verb!static! keyword is used to defined file-scope
(Sect.\ref{sec:static_C}), but it also has other meanings
(Sect.\ref{sec:static_C}).

Let's see the difference when use \verb!static! specifier with variable vs.
function.
\begin{enumerate}
    \item the \verb!static! global variable is seen everywhere in the file (but
    not from outside). 
    
    To make the non-static global variable seen from another
    file, on that another file, declare the same variable (at file scope) with an
  \verb!extern! specifier in the front. 

Example:
\begin{verbatim}
/* file.h */
static int my_variable;  /* can be seen only in file.h */

int glob_var = 0;  /* can be seen from another file */
\end{verbatim}
and
\begin{verbatim}
/* file2.c */
#include <file1.h>

extern int glob_var;  /* reference to the value in file.h */


\end{verbatim}

     \item \verb!static! function: by default, all functions have \verb!extern!
     semantics, i.e. which are accessible from any  other files. So, to make
     APIs that are local to the file only, we define these local functions as
     \verb!static! functions. 
  
    \end{enumerate}
  
IN SUMMARY: For multi-file scope, a variable/function need to be declared as
\verb!extern!. Unlike variables, a function has \verb!extern! semantics by
default. A global variable, by default, doesn't have \verb!extern! keyword.
That explain why in C code, we typically wrap everything using 

\begin{verbatim}

#ifndef _FILE_H_
 #define _FILE_H_
 extern {
#endif 

  /* ADD THE C-code here */

#ifndef _FILE_H_
}
#endif
\end{verbatim}



\section{Scope in C++: block scope, file scope}
\label{sec:scope_in-C++}

In C++, there is no concept of program scope.
By default, without any specifier, the variable, e.g. \verb!x!,
has file scope. Thus, the role of \verb!static! specifier to indicate file scope
is no longer used in C++. The meaning of \verb!static! is thus different in C
vs. C++.




\section{Local variables in C vs. C++}
\label{sec:variables_C_C++}

In C, local variables MUST always be defined at the beginning of the block, and
it can be used anywhere in that block. Since C++, variable definition is treated
as an executable statements, thus it can be defined anywhere and can ONLY be
used from that location to the end of the block.

\begin{verbatim}
main()
    {
        float pi = 3.142;   /* Usual location for variable definitions  */
        int ii ;
        
        cout << "PI is " << pi << endl;
        
        int Count = 1;  // This is WRONG in C. Yet C++ allows us to place a definition here.
        
        while (Count < 10)
        {
            cout << Count << endl;
        }
    }
\end{verbatim}

As C++ allows the variables to be used anywhere, in the \verb!for! loop, C++
allows the indexing variable to be defined inside the loop
\begin{verbatim}
for (int i = 0; i < size; i++)
{ 

}
\end{verbatim}

In general, both C and C++, a local variable is visible within the nested block,
unless a variable of the same name is defined within that nested block.
\begin{verbatim}
{
  int i = 0;
  {
     float i;
  }
}
\end{verbatim}


\section{Global variables in C vs. C++}
\label{sec:variable_global}

A global variable is a variable with global scope, i.e. whose lifetime span the
entire runtime of the program. A global variable is not \verb!extern! nor
\verb!static! by default in C and C++.

A variable defined outside any function scope is visible within the file, i.e.
between their declaration and the end of the file (file \verb!.c!), unless
shadowed by a local variable of the same name. 
\begin{verbatim}
// file_1.c

int var_Glob;

void func_1() {
 ...
}
\end{verbatim}
In addition, these variables have external linkage, i.e. they are visible not
only to the {\it compilation unit} (e.g. \verb!file_2.c!) containing their
declaration (need to use \verb!extern! for declaration)
\begin{verbatim}
// file_2.c

extern int var_Glob;
\end{verbatim}
but also to any other compilation unit that is linked to form the complete
program. NOTE A program can have one or multiple source files.



\begin{enumerate}
  \item A variable with \verb!static! is defined restricted to the current
  source file. It means that a variable declared with \verb!static! has
  internal linkage, i.e. it can be used in multiple source files, but each
  source file has its own memory space for that variable.
  
  \item A variable with \verb!extern! is declared and its definition is in some
  other files. A variable definition must be without the \verb!extern! keyword.
  Typically, the declaration of the variable using \verb!extern! is put into a
  single header file that can be included in many other source files.
\end{enumerate}

NOTE: Using \verb!extern! for a variable is different from using that for a
function. An \verb!extern! variable means the declaration, and the definition is
at somwehere, and thus can be found non-static at link time. A \verb!extern!
function means the function is defined elsewhere (in .c file). A function has
\verb!extern! by default.

\section{Declaration vs. Definition of an identifier}
\label{sec:declaration_definition}

There are two stages to define a variable or a function: declaration and
definition. Definition is the common scenario when you first write C/C++ code,
but in advanced code, you may need to use declaration, when you want to share
the same identifier across the scope of files or libraries.

\begin{enumerate}
  \item Definition instantiate/implement the identifier, e.g. allocates the
  memory (in the case of variable), and function implementation (in the case of
  function). In a program, we can have as many declaration if we want (at
  different source files or header files), but only one definition (i.e. in a
  single source file).
  
\begin{verbatim}
extern const int bar = 5; /define 
int bar;
int g(int lhs, int rhs) {return lhs*rhs;}
double f(int i, double d) {return i+d;}
class foo {};
\end{verbatim} 


  \item Declaration help the compiler to know the identifier is a variable of
  a particular type (in the case of variable), or it's an object of a class
  or a function (e.g. return type as well as types of function's arguments).
  The real location of the identifier is not know at runtime.
    
\begin{verbatim}
extern int bar;  //MUST be without an initializer
extern int g(int, int);
double f(int, double); // extern can be omitted for function declarations
class foo; // IMPORTANT: no 'extern' allowed for class declarations

extern "C"
{
  void foo(); //declare
}

typedef long LONG_32;  // declares LONG_32
using namespace std;   // declares std

\end{verbatim}

\end{enumerate}
\textcolor{red}{We can have as many declaration of an identifier, but there
should be one definition of
it}.\footnote{\url{http://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration}}

\begin{mdframed}

In C99 standard: a definition is when (1) it causes storage to be reserved for
that identifier (when it's an object), or (2) it include the function body
(when the identifier is a function), or (3) a \verb!typedef! name or an
\verb!enum const! (enumeration constant). 

In C++ standard: a definition is when (1) fuction with body, (2) 'extern'
specifier or linkage-specification without an initializer nor a function-body,
(3) a static data member in a class declaration, (4) typedef declaration, (5)
using declaration or using directive.

In C++11 standard:
\begin{verbatim}
A declaration is a definition unless it declares a/n:

    opaque enum - enum X : int;
    template parameter - T in template<typename T> class MyArray;
    parameter declaration - x and y in int add(int x, int y);
    alias declaration - using IntVector = std::vector<int>;
    static assert declaration - static_assert(sizeof(int) == 4, "Yikes!")
    attribute declaration (implementation-defined)
    empty declaration ;

Additional clauses inherited from C++03 by the above list:

    function declaration - add in int add(int x, int y);
    extern specifier containing declaration or a linkage specifier - extern int a; or extern "C" { ... };
    static data member in a class - x in class C { static int x; };
    class/struct declaration - struct Point;
    typedef declaration - typedef int Int;
    using declaration - using std::cout;
    using directive - using namespace NS;

\end{verbatim}

\end{mdframed}

In C++, it's more complicated. This is a declaration
\begin{verbatim}
struct S; // declares S
\end{verbatim}

but this is a definition
\begin{verbatim}
struct S { int a; int b; }; // defines S, S::a, and S::b
struct x {};
\end{verbatim}

Or we can have a declaration inside a definition, where \verb!static! refers to
declaration
\begin{verbatim}
struct X
{
    int a;         // defines a
    static int b;  // declares b
};
\end{verbatim}

In C++, depending on what type of $T$, it can be a declaration or a defition
\begin{verbatim}
typedef void T();
T t; // declaration of function "t"

struct X { 
  T t; // declaration of function "t".
};

typedef int T;
T t; // definition of object "t".
\end{verbatim}
Especially, when you use template
\begin{verbatim}
template <typename T>
struct X { 
  static int member; // declaration
};

template<typename T>
int X<T>::member; // definition

template<>
int X<bool>::member; // declaration!
\end{verbatim}
The last case means that ``If it comes to instantiating X<bool>::member, then
don't instantiate the definition of the member from the primary template, but
use the definition found elsewhere''. Somewhere else we need to define it
\begin{verbatim}
template<>
int X<bool>::member = 1; // definition, belongs into a .cpp file.
\end{verbatim}


Example: C++11
{\small \begin{verbatim}
// except one all these are definitions
int a;                                  // defines a
extern const int c = 1;                 // defines c
int f(int x) { return x + a; }          // defines f and defines x
struct S { int a; int b; };             // defines S, S::a, and S::b
struct X {                              // defines X
    int x;                              // defines non-static data member x
    static int y;                       // DECLARES static data member y
    X(): x(0) { }                       // defines a constructor of X
};
int X::y = 1;                           // defines X::y
enum { up , down };                     // defines up and down
namespace N { int d; }                  // defines N and N::d
namespace N1 = N;                       // defines N1
X anX;                                  // defines anX


// all these are declarations
extern int a;                           // declares a
extern const int c;                     // declares c
int f(int);                             // declares f
struct S;                               // declares S
typedef int Int;                        // declares Int
extern X anotherX;                      // declares anotherX
using N::d;                             // declares N::d


// specific to C++11 - these are not from the standard
enum X : int;                           // declares X with int as the underlying type
using IntVector = std::vector<int>;     // declares IntVector as an alias to std::vector<int>
static_assert(X::y == 1, "Oops!");      // declares a static_assert which can render the program ill-formed or have no effect like an empty declaration, depending on the result of expr
template <class T> class C;             // declares template class C
;                                       // declares nothing
\end{verbatim}}



\section{Aliasing rules}
\label{sec:aliasing_rules}

It's important to understand {\bf aliasing rules}, as it can be confusing due to
two different perspectives: from a developers who use compilers, and developers
who write compilers. Depending on the languages (C or C++), and the versions
(C89/C90 or C98/C99 or C++98 or C++0x), the aliasing rules can be different.
\url{http://dbp-consulting.com/StrictAliasing.pdf}

Aliasing occurs when more than one lvalue (Sect.\ref{sec:rvalue_lvalue}) refers
to the same memory location. The lvalues here are typically pointers. It means
that when you modify one lvalue, it potentially affect to another lvalue.

\begin{Verbatim}
int anint;
int *intptr=&anint;
\end{Verbatim}

\textcolor{red}{When aliasing occurs, it reduces the level of optimization can
be done by the compiler}. The list of cases that aliasing can occur is written
down in the C/C++ standards. In other words, any thing not in the list is
considered safe for optimization by the compiler. If you write your code that
follows these rules, then the compiler can freely optimize the code. This is
known as {\it strict-aliasing}. Example: under strict-aliasing, incompatible
types (double, and int) cannot alias. In other words, the compiler assume that
\verb!dblptr! can never at the same address with  \verb!&anint!. If your code
break this rule, this is dangerous (see below).
\begin{Verbatim}
int anint;
void foo(double *dblptr)
{
 anint=1;
 *dblptr=3.14159;
 bar(anint);
}

\end{Verbatim} 

This is C9899:201 rules: alias can occur with objects 
\begin{enumerate}
  \item of compatible types, or differ only by the addition of any combination
  of sign (\verb!signed!, \verb!unsigned!), or qualifier (\verb!const! or
  \verb!volatile!) to the type. Example: the two pointers below can point to the
  same thing: a pointer to \verb!long!, and a pointer to \verb!const unsigned long!
  
  \item an aggregate (\verb!struct! or \verb!class!) or \verb!union! type can
  alias the types contained inside it. Example: if a function with two
  arguments: one is a pointer to an \verb!int!, and another one is a pointer to
  a \verb!struct! or \verb!union! that has an \verb!int! member, then the
  first argument can possibly pointing to the \verb!int! contained inside
  that \verb!struct! or \verb!union!.
  
  \item a character type (\verb!char*, signed char*, unsigned char*!) can point
  to anything, i.e. it can alias anything in memory
  
  \item (C++ only) a \verb!const! or \verb!volatile! qualified base class type
  of a dynamic type can alias the child type. Example: class 'animal' is the
  base class for the class 'dog', then the pointer to the object of type
  \verb!class dog! and the pointer to the object of type \verb!class animal! can
  alias. 
\end{enumerate}
If your code breaks in rule, you may get warning about breaking strict-aliasing
rule, and probably the program give you unexpected result. 
\begin{verbatim}
dereferencing type-punned pointer will break strict-aliasing rules on line ...
\end{verbatim}

Example: this code swap the first 16-bit with the second 16-bit of a 32-bit
value. Suppose the input is \verb!00000020!HEX then the output should be 
\verb!00200000!HEX. However, the code below return \verb!00000020!HEX.
 
\begin{Verbatim}
uint32_t
swaphalves(uint32_t a)
{
 uint32_t acopy=a;
 uint16_t *ptr=(uint16_t*)&acopy;// can't use static_cast<>, not legal.
 // you should be warned by that.
 uint16_t tmp=ptr[0];
 ptr[0]=ptr[1];
 ptr[1]=tmp;
 return acopy;
}

int main() {
 uint32_t a; a=32; cout << hex << setfill('0') << setw(8) << a << endl;
 a=swaphalves(a); cout << setw(8) << a << endl;
}
\end{Verbatim} 
The reason is that \verb!ptr! is a pointer to type \verb!uint16_t!, which
overlap with the first 16-bit of \verb!acopy!. By strict-aliasing rule, this is
assumed not to happen, as data pointed by \verb!ptr! is \verb!uint16_t! while
data pointed by \verb!acopy! is \verb!uint32_t!.  Thus, the compiler treats any
change to \verb!ptr! is not affected to \verb!acopy!. Also, as there is no
change to \verb!acopy!, then the optimized code just return the original
value of \verb!acopy!. This explains why the output value is unchanged. 

In other words, the code above violates the strict-aliasing rule. To ask
the compiler not assuming strict-aliasing, we need to compile the code with the
given option to get the right output, yet the generated code is slower
\begin{itemize}
  \item in GCC: use \verb!-fno-strict-aliasing -O3 -std=c99! which applies for
  all the code, which is not we usually want
\end{itemize}
To enforce strict-aliasing rule, we compile the code with the flags
\begin{verbatim}
-fstrict-aliasing -Wstrict-aliasing=2 -O3 -std=c99 
\end{verbatim}
Use \verb!-Wstrict-aliasing! for most common errors related to type-punning;
while \verb!-Wstrict-aliasing=2! generates warns for a larger class of cases;
yet false positive (i.e. wrong warning) may be returned.

One solution to the above is to use a \verb!union! type inside the function, as
the compiler assume that members of a union starts from the same address, i.e.
aliasing occurs. By using \verb!union! (one full-size member, and one array of
smaller size), we can easily access first-half and second-half two-bytes easily.
However, this code works for C, but not guarantee to be portable in C++ (see a
better version with \verb!memcpy()! below)
\begin{Verbatim}
uint32_t
swaphalves(uint32_t a)
{
 typedef union { 
    uint32_t as32bit; 
    uint16_t as16bit[2]; 
 } swapem;
 
 swapem s={a};
 
 uint16_t tmp;
 tmp=s.as16bit[0];
 
 s.as16bit[0]=s.as16bit[1];
 s.as16bit[1]=tmp;
 return s.as32bit;
}
\end{Verbatim}

The efficient version that works for both C and C++ is using two
calls to \verb!memcpy()!. NOTE: The assembly code exactly the same as the above
solution with \verb!union!, but now works for both C and C++.
\begin{Verbatim}
uint32_t
swaphalves(uint32_t a)
{
 uint16_t as16bit[2],tmp;
 memcpy(as16bit, &a, sizeof(a));
 
 tmp = as16bit[0];
 as16bit[0] = as16bit[1];
 as16bit[1] = tmp;
 
 memcpy(&a, as16bit, sizeof(a));
 return a;
}

\end{Verbatim}

It would be better if we can tell the compiler explicitly that two pointers are
not aliasing. If the programmers tell the compiler which part of the code is not
aliasing, the compiler then can do the job better.
In C (from C99), but not C++, you can tell the complier that a pointer to
something is not alias using the \verb!restrict! keyword
(Sect.\ref{sec:pointer_restrict}).

References:
\begin{enumerate}
  \item
  \url{http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html}
\end{enumerate}


\section{Constant Expression vs. Read-only object}
\label{sec:constant-expression}
\label{sec:read-only-object}

\begin{verbatim}
const int MAX = 1024;
\end{verbatim}
MAX is not a constant expression, it's the name of a read-only object.
That means you can't use it in a case label.

\begin{verbatim}
enum { MAX = 1024 };
\end{verbatim}
then MAX is a constant expression of type int (in C language), usable in any
context where you could use the constant 1024. In C++ language (Sect.\ref{sec:enum-C++}), the element of \verb!enum! is of enumerated type,
not \verb!int!, but you can use declared constant objects as constant expressions (as long as the initializer is a constant expression).


\begin{verbatim}
#define MAX 1024
\end{verbatim}



\section{One Defintion Rule (ODR)}
\label{sec:one-definition-rule}

A definition is considered as 
\begin{verbatim}
class C {}; // first definition of C
class C {}; // error, second definition of C
\end{verbatim}

\textcolor{red}{We don't need definition}: In the following case, a declaration, but NOT a definition, is required
\begin{verbatim}
struct S;     // declaration of S
S * p;        // ok, no definition required
void f(S&);   // ok, no definition required
void f(S*);   // ok, no definition required 
S f();        // ok, no definition required - this is a function declaration only!
\end{verbatim}
Here, forming a pointer to S or defining a function taking a
reference to S are examples of legal constructs, because they do not require the
type of S to be complete. Therefore, a definition is not required.

\textcolor{red}{We do need definition}: Defining an object of type S, a function
taking an argument of type S, or using S in a sizeof expression are examples of
contexts where S must be complete, and therefore require a definition.

\begin{verbatim}
S s;          // error, definition required
sizeof(S);    // error, definition required

\end{verbatim}

 \url{https://en.wikipedia.org/wiki/One_Definition_Rule}

Where and how many definition can be used?
\begin{enumerate}
  \item  
  
A program consisting of multiple header files and source files will typically
have more than one definition of a type, but not more than one definition per
translation unit.

  \item 
\end{enumerate}

\section{Coding styles}
\label{sec:coding_style-C/C++}

This is a very important section that you are supposed to know from the
beginning

\subsection{Blink coding style}

This is based on Blink web layout engine project
\url{http://dev.chromium.org/blink/coding-style}


\subsection{Chromium coding styles (Google C++ style)}

\url{http://dev.chromium.org/developers/coding-style}


\subsection{header and source file}
\label{sec:header-and-source-files-C++}

In C/C++, there are two types of files: 
\begin{itemize}
  \item header file: .h, .hp
  \item source file: .c, .cc, .cpp
\end{itemize}

The header file contains the declaration of the class, functions, class methods.
In other words, it contains the interface or signature that will be included in
other source files. The source file contains the definition for the class
methods, functions. Sect.\ref{sec:modules-in-C++} describes how we can manage
complex C++ codes by organizing into modules.


As far as C++ goes, there won't be any issues with using one header file and
splitting the actual implementations of the functions between 2 files. It must follows 
{\bf One Definition Rule} (ODR) - Sect.\ref{sec:one-definition-rule}.


It is important that the declaration is included in a source
file maximize once. Thus, the content of the header file is always wrapped
inside a 
\begin{verbatim}
#ifndef _SOME_MACROS_
 #define _SOME_MACROS_
 
   // header file content
   
#endif
\end{verbatim}
It is recommended to use the macro name following the format
\verb!<PROJECT>_<PATH>_<FILE>_H_!, with \verb!<PATH>! is the sub-path in the
project. There is an alternate way is using \verb!#pragma once!
(Sect.\ref{sec:ifndef_pragma-once})

Example:
\begin{verbatim}
//## file1.h
#ifndef _PROJECT_FILE1_H
  #define _PROJECT_FILE1_H

class AClass
{
};

#endif



// file1.cpp

#include file1.h
AClass::AClass() 
{
};


// file2.cpp

#include "file1.h"

// use class, functions from file1.h
\end{verbatim}

\subsection{\#pragma once vs. \#ifndef (guards)}
\label{sec:ifndef_pragma-once}

Both helps to ensure that the header file will be included once. 
guards or \verb!#ifndef! is the standard. However,
\verb!#pragma once! is not the standard, even though it is widely supported in
many compilers. The advantage of using \verb!#pragma once! is that
\begin{itemize}
  \item \#pragma once is less prone to making mistakes and it is less code to
  type. This can make a significant in compile time as the C preprocessor does
  not have to be involved.
  
  \item some compilers are designed to compile faster if using \verb!#pragma once!
  \#pragma once allows the compiler to skip the file completely when it occurs
  again - instead of parsing the file until it reaches the \#include guards.
  
  gcc also optimize using both \#pragma once and guards. Visual C++ optimize for
  \#pragma once. 
\end{itemize}

Google suggest not to use \verb!#pragma once! and sticks with the standard
\url{http://google-styleguide.googlecode.com/svn/trunk/cppguide.html}


To wait until \verb!#pragma once! becoming standards, you can use both
\begin{verbatim}
#pragma once
#ifndef BLAH_H
#define BLAH_H


// ...

#endif
\end{verbatim}

\subsection{\#pragma warning}
\label{sec:pragma_warning}

This pragma tells the compiler how to deal with warning. However, you can also
deal with warning at the compiler option level (Sect.\ref{sec:warning_level}).


At the beginning of the source file, you can tell the compiler to ignore certain
warning (i.e. \verb!disable!), or display the warning only once (i.e.
\verb!once!), report the warning as error (i.e. \verb!error!), apply a specific
warning level (i.e. 1, 2, 3, 4).
The default value is \verb!default! (reset warning behavior to its default
setting). Since VS 2008, a new option is \verb!suppress! (push the current state
of the pragma on the stack)

{\bf IMPORTANT}:
\begin{itemize}
  \item maximum 56 \verb!#pragma warning! is allowed in one compiland (i.e. single source unit)
  
  \item the compiler will add 4000 to any warning number that is
between 0 and 999. 

  \item For warning associated with code generation, i.e. numbers in the range
  4700-4999, the \verb!#pragma warning! has effect only when placed outside function
  definitions. It means that if it is placed inside a function, it will not take effect on that funciton, but on the next function
\end{itemize}

\begin{verbatim}
#pragma warning(disable : 4793)

#pragma warning( disable : 4507 34; once : 4385; error : 164 )

#pragma warning( error : 164 )        // Report warning 4164
                                      //  as an error.
                                      
#pragma warning( disable : 4507 34 )  // Disable warning messages
                                      //  4507 and 4034.                                      
\end{verbatim}

NOTE: If we want to reset the warning state as a group, we put the groups of warning in between \verb!push! and \verb!pop!
\begin{verbatim}
#pragma warning( push [ ,n ] )
#pragma warning( pop )
\end{verbatim}

Example:
\begin{verbatim}
#pragma warning( push )
#pragma warning( disable : 4705 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4707 )
// Some code
#pragma warning( pop ) 
\end{verbatim}

\url{https://msdn.microsoft.com/en-us/library/2c8f766e(v=vs.71).aspx}


\subsection{\#pragma managed}
\label{sec:pragma_managed}

The /clr compiler option (Sect.\ref{sec:clr_option}) provides module-level
control for compiling functions either as managed or unmanaged. The managed and
unmanaged pragmas enable function-level control for compiling functions as
managed or unmanaged.
\begin{verbatim}
#pragma managed
#pragma unmanaged
\end{verbatim}
Since VS 2005+, there are two new pragmas
\begin{verbatim}
#pragma managed([push,] on | off)
#pragma managed(pop)
\end{verbatim}

How to use:
\begin{enumerate}
  \item \verb!/clr! must be used for the pragma managed/unmanaged to be detected.
  \item Add the pragma preceding a function but not within a function body.
  \item Add the pragma after \verb!#include! statements (as it may affect the compiling of included files)
\end{enumerate}

Example: the module is compiled with \verb!/clr! option, and we want some function inside is not managed
\begin{verbatim}
// compile with: /clr
#using   <mscorlib.dll>
#include <stdio.h>

// func1 is managed
void func1(void)
{
   System::Console::WriteLine("In managed function.\n");
}

#pragma unmanaged

// func2 is unmanaged
void func2(void)
{
   printf("In unmanaged function.\n");
}

#pragma managed

// main is managed
int main()
{
   func1();
   func2();
}
\end{verbatim}
\url{https://msdn.microsoft.com/en-us/library/0adb9zxe(v=vs.71).aspx}


\section{Overload vs. Override}
\label{sec:override}
\label{sec:overload}

Overloading occurs when two or more methods in one class have the same method
name but different parameters.

Overriding means having two methods with the same method name and parameters
(i.e., method signature), and same return type.
Example: class method overriding (Sect.\ref{sec:method_overriding})


\section{Traits}

It is common to see different pieces of code that have basically the same
structure, but contain variation in the details.
\begin{enumerate}
  
  \item  In 'C' this might be done by using function pointers, 
  
  Example: C Standard Library qsort function.
  
  \item  In C++ by using virtual functions
\end{enumerate}
Unfortunately, using the above approach, the chocie of real action happens at runtime rather at compile time, and became
with a runtime overhead.

To avoid this runtime binding, C++ introduces generic programming, with
templates, eliminating the need for runtime binding. In other words, the
compiler now is smarter and then can generate different functions, depending on
the specific data type being used, e.g. the same algorithm will not work
optimally with every data structure.

Further more, a new feature called {\bf traits} is added into C++.
\begin{verbatim}

Think of a trait as a small object whose main purpose is to carry information
used by another object or algorithm to determine "policy" or "implementation
details". - Bjarne Stroustrup
\end{verbatim}

Traits in C:  we have limits.h, and float.h, which are used to determine
the various properties of the integer and floating point types.
NOTE: You have to remember the type prefix and the trait, for example,
\verb!DBL_MAX! contains the "maximum value" trait for the double data type

Traits in C++ (better): By using a traits class such as \verb!numeric_limits!
the type becomes part of the name. Not only that, but \verb!numeric_limits!, as with
most traits, can be extended to include your own custom types (such as a fixed
point, or arbitrary precision arithmetic classes) simply by creating a
specialisation of the template.

IMPORTANT: \verb!numeric_limits! is just an example of traits in action, you can also 
create traits classes of your own.


\begin{enumerate}
  \item  \verb!std::numeric_limits!: 
  
  Example: maximum value for a double becomes \verb!numeric_limits< double >::max()!
\begin{lstlisting}
template< class T > 
T findMax(const T const * data, 
         const size_t const numItems) { 
  // Obtain the minimum value for type T 
  T largest = 
      std::numeric_limits< T >::min(); 
  for(unsigned int i=0; i<numItems; ++i) 
  if (data[i] > largest) 
  largest = data[i]; 
  return largest; 
} 
\end{lstlisting}

  \item 
\end{enumerate}

\subsection{write your own traits: default and specialization behavior}

We have a complete traits type that can be used to detect if any given type,
passed in as a template parameter, is void

\begin{verbatim}
template< typename T > 
struct is_void{ 
  static const bool value = false;
};


template<> 
struct is_void< void >{ 
  static const bool value = true; 
};
\end{verbatim}

Example 2: \verb!boost::is_pointer!
- the most common sort of trait class specialisation, e.g. at partial specialisation

\begin{verbatim}
# default template
template< typename T > 
struct is_pointer{ 
  static const bool value = false; 
};

#  partial specialisation for all pointer types 
template< typename T > 
struct is_pointer< T* >{ 
  static const bool value = true; 
};
\end{verbatim}

\section{Tips and Tricks}

\subsection{Forward declaration}
\label{sec:forward_declaration}

\begin{verbatim}
class A;  // forward declaration (i.e. A is an incomplete type)

class B{

  // use class A
  A *b; // this is okay, as using pointer
  
  friend int A::foo_method() ; // this is ERROR
  // friend A ; // this is OKAY
}

class A{
  // definition
  
  int foo_method();
}

\end{verbatim}

When using forward declaration of objects in C++, this is important
\begin{enumerate}
  \item At the time of using forward declaration, the class is considered as
  an {\it incomplete type} as the compiler doesn't know how big of the class, or
  what methods it has. Thus, you cannot allocate an {\it imcoplete type} or
  using any of its member functions. 
  
It is allowed to use a pointer to an imcomplete type.

  \item You cannot reference the members of an implete type (as mentioned
  above). This is solved by putting the interface in the header file and the
  implementation in the code file.
  
  \item Try to avoid {\it circular reference} wherever possibles
\end{enumerate}

Example: This is the solution when we have two class \verb!foo! and \verb!bar!
in which one use the other. How to do this? foo.h
\begin{verbatim}
#ifndef __FOO_H_INCLUDE
    #define __FOO_H_INCLUDE
    #ifndef __FOO_H_DEFINED
        #define __FOO_H_DEFINED
        class foo;
        #include "bar.h"
    #endif
    class foo{
        bar *a;
        int b;
        public:
        foo( int _b );
        bar& getbar();
        int getb();
        void setbar( bar* _a );
    };
#endif
\end{verbatim}
and bar.h
\begin{verbatim}
#ifndef __BAR_H_INCLUDE
    #define __BAR_H_INCLUDE
    #ifndef __BAR_H_DEFINED
        #define __BAR_H_DEFINED
        class bar;
        #include "foo.h"
    #endif
    class bar{
        foo *a;
        int b;
        public:
        bar(int _b );
        foo& getfoo();
        int getb();
        void setfoo( foo* _a );
    };
#endif
\end{verbatim}
and finally main.cpp
\begin{verbatim}
#include<iostream>
#include "foo.h"
#include "bar.h"

foo::foo( int _b ){ b = _b;}
int foo::getb(){ return b; }
bar& foo::getbar(){ return *a; }
void foo::setbar( bar* _a){ a = _a; }

bar::bar( int _b ){ b = _b;}
int bar::getb(){ return b; }
foo& bar::getfoo(){ return *a; }
void bar::setfoo( foo* _a ){ a = _a; }



int main(){
    foo a(5);
    bar b(20);
    a.setbar(&b);
    b.setfoo(&a);
    std::cout   << a.getbar().getfoo().getbar().getb() 
                << "\n" 
                << a.getbar().getfoo().getbar().getfoo().getb();
    return 0;
}
\end{verbatim}
\url{http://stackoverflow.com/questions/15076026/c-forward-declaration-and-incomplete-type-is-not-allowed-error}

\subsection{xvalue, glvalue, prvalue (C++11)}
\label{sec:xvalue_glvalue_prvalue}

In C++03, an expression is either {\bf Lvalue} or {\bf Rvalue}
(Sect.\ref{sec:rvalue_lvalue}). In C++11, totally 5 options with 3 new: {\bf
xvalue}, {\bf glvalue} or {\bf prvalue}.

Prior to C++11, \textcolor{red}{identity} is the main factor to discriminate
Lvalue and Rvalue, i.e. if a value has an identity then it's a Lvalue. However,
since C++11, rvalue reference was added which effectively allows you to prolong
their lifetime as if they were Lvalues.
In other words, another factor: \textcolor{red}{mobility} need to be examined.

The combination of identity (i) and mobility (m), with a minus sign indicating
negation, produces 5 meaningful value categories in C++11 as given
above.\footnote{\url{http://blog.smartbear.com/development/c11-tutorial-explaining-the-ever-elusive-lvalues-and-rvalues/}}.
\begin{enumerate}
  \item i-m value: Lvalue = non-movable objects with identity. Pointer
  dereference, *p, is a Lvalue. Similarly, dereferencing a pointer to a function
  is also a Lvalue.
  
  \item im : Xvalue = (eXpiring value) an object with identity yet near the end
  of its lifetime (e.g. before its resources are removed), e.g. std::move(mystr)
  
  \item i : GLvalues = (Generalized Lvalues)  which includes Lvalue and Xvalues
  \item m : Rvalues = includes Xvalue, temporaries, and values with no identity
  \item -im : PRvalues = (Pure Rvalues) which are Rvalues but not Xvalue. It
  includes literals and functions whose return type is not a reference.
\end{enumerate}
In C++11, every expression belong to exactly one of the 3 value classification:
Lvalues, Xvalues or PRvalues.


\url{http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues}


\subsection{Rvalue and Lvalue}
\label{sec:rvalue_lvalue}

Until C++03, every C++ expression is either Lvalue or Rvalue. The concept of
Lvalue and Rvalue were introduced in a seminal article by Barron et al. (1963)
for CPL language
\footnote{\url{http://comjnl.oxfordjournals.org/content/6/2/134.full.pdf+html}}.
It purely means something on the left-hand side or right-hand-side of an
assignment. With B language, developed by Dennis Ritchie
(Sect.\ref{sec:BCPL_C}), he borrowed the term Lvalue to refer to a memory region
to which the C program can write the result from the right-hand side of the
assignment. He left out Lvalue, as any thing not Lvalue is Rvalue. Later on,
K\&R C and ISO C++ defined Rvalue. C++11 even extends the notion of Rvalue by
letting you bind rvalue references to them
(Sect.\ref{sec:xvalue_glvalue_prvalue}).
\footnote{\url{http://blog.smartbear.com/development/c11-tutorial-explaining-the-ever-elusive-lvalues-and-rvalues/}}



Lvalue = locator value, represents an object occupies some identifiable location
in memory (i.e. with an address). Initially, when Lvalue was defined in C, it
means ``values suitable for left-hand-side of assignment''. Later on, when ISO
add \verb!const! keyword, it has to be redefined ``not all Lvalue can be
assigned to. Those that can are called {\it modifiable Lvalues}''.  For
simplicity, a Lvalue refers to an object that persists beyond a single
expression. \textcolor{red}{An array name is not a modifiable Lvalues, as it is
a constant pointer to an array.}

\begin{verbatim}
const int a = 10; // 'a' is an lvalue
a = 10;           // but it can't be assigned!
\end{verbatim}
This is the defintion in C99
{\small
\begin{verbatim}
[...] an lvalue that does not have array type, does not have an incomplete type,
does not have a const-qualified type, and if it is a structure or union, does
not have any member (including, recursively, any member or element of all
contained aggregates or unions) with a const-qualified type.  
\end{verbatim}
}

Rvalue = not Lvalue. Based on the fact that every expression is either lvalue or
rvalue. In C++03, Rvalue are values that have no identity, and are accessible
only inside the expression in which they are created. Examples: literal constant
(e.g. 7, 'a', ``hello, world''), temporaries (e.g. (y*z)). Here, a temporary
object of \verb!int! can be created to store the result of (y*z), and {\it
expires} once its expression is fully evaluated.
\begin{verbatim}
int x=0;
x=(y*z)+w;

// we can create a temporary object
cout<<std::string ("test").size()<<endl;

string ()={"hello"}; //creates a temp string

string("hello"); //creates a temp string
\end{verbatim}

So, any assignment requires a Lvalue on the left side of equal (=) sign, and a
Rvalue on the right side. Example: a constant or an expression is NOT an Lvalue
as they are temporary values, i.e. they just reside in some temporary registers
for the duration of the computation and thus has no given memory address. So, we
cannot assign any thing to a non-memory addressable location
\begin{verbatim}
4 = var;       // ERROR!
(var + 1) = 4; // ERROR!
\end{verbatim}

In an expression, a Lvalue is {\it implicitly } converted to Rvalue. For
explicit conversion, the unary * (dereference) operator takes an Rvalue and
produce a Lvalue as a result. Meanwhile, the address-of operator \& takes an
Lvalue and return a Rvalue
\begin{verbatim}
nt a = 1;     // a is an lvalue
int b = 2;     // b is an lvalue
int c = a + b; // + needs rvalues, so a and b are converted to rvalues
               // and an rvalue is returned
               
int arr[] = {1, 2};
int* p = &arr[0];
*(p + 1) = 10;   // OK: p + 1 is an rvalue, but *(p + 1) is an lvalue


int var = 10;
int* bad_addr = &(var + 1); // ERROR: lvalue required as unary '&' operand
int* addr = &var;           // OK: var is an lvalue
&var = 40;                  // ERROR: lvalue required as left operand
                            // of assignment               
\end{verbatim}
\textcolor{red}{A Rvalue CANNOT be converted to Lvalue}.

Example: Any expression returns an object by value is an Rvalue
\begin{verbatim}
int& func();
int func2();

func(); //this call is an lvalue
func2(); //this call is an rvalue

sizeof(short); //rvalue
new double; //new expressions are rvalues
S::S() {this->x=0; /*this is an rvalue expression*/}
\end{verbatim}
\textcolor{red}{A function's name, not to be confuse with a function call, is a
Rvalue that evaluates to the function's address}. An array is a rvalue that
evaluates and return to the address of the first element in the array. 

A function can either returns a Lvalue or a Rvalue. \textcolor{red}{The ability
to return Lvalue from functions is important in C++ for implementing some
overloaded operators}.
\begin{verbatim}
int globalvar = 20;

int& foo()
{ // return Lvalue
    return globalvar;
}


int& foo()
{ // return Rvalue
    return 2;
}
\end{verbatim}

Example: overload the bracket [] operator in classes that implements some kind
of lookup. Here we use \verb!std::map<>!
\begin{verbatim}
std::map<int, float> mymap;
mymap[10] = 5.6;
\end{verbatim}

\url{http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/}

\subsection{value type vs. reference type}

\begin{mdframed}
\verb!int, bool, float! are specific types

interfaces and delegates (Sect.\ref{sec:delegates}) are {\it kinds} of types. 

\verb!struct, enum! are kinds of value types.
\end{mdframed}

If an identifier is of a {\bf value type}, then the value it holds is the
information itself. If an identifier is of a {\bf reference type}, then the
value it holds is either NULL or a way of navigating to an object containing the
information.

{\bf reference} vs. {\bf reference type}:


NOTE: 
\begin{enumerate}
  \item 
\end{enumerate}

\url{http://yoda.arachsys.com/csharp/references.html}

\subsection{delegate (VC++/CLI Windows)}
\label{sec:delegates} 

In C++, as a variable can be a pointer, a function can also be a pointer
(Sect.\ref{sec:function_pointer}) and can be passed to a function via the
argument under the name {\bf callback function}. With .NET framework and
C++/CLI, the concept is defined in a different name: {\bf delegates}.
\textcolor{red}{It's most commonly used in conjunction with events}.
\url{http://msdn.microsoft.com/en-us/library/hh755798.aspx}

Typically, you declare a delegate at the namespace scope, and then
associate it with a class method. Declare the delegate at the namespace
scope
\begin{verbatim}
public delegate void PrimeFoundHandler(int result);

event PrimeFoundHandler^ primeFoundEvent;  // an event has the delegate type    
\end{verbatim}
NOTE: ALWAYS use \verb!^! symbol to refer to the delegate type.

Example: First, declare the delegate type
\begin{verbatim}
public delegate Platform::String^ CustomStringDelegate(ContactInfo^ ci);
\end{verbatim}
then declare the class member of that type
\begin{verbatim}
public ref class ContactInfo sealed
{        
public:
    ContactInfo(){}
    ContactInfo(Platform::String^ saluation, Platform::String^ last, Platform::String^ first, Platform::String^ address1);
    property Platform::String^ Salutation;
    property Platform::String^ LastName;
    property Platform::String^ FirstName;
    property Platform::String^ Address1;
    //...other properties

    Platform::String^ ToCustomString(CustomStringDelegate^ func)
    {
        return func(this);
    }       
};
\end{verbatim}
then in the code, we can associate the delegate with a given class's method. The
advatage of using delegate is that it allows us to define a 'delegate' object
that can do different things, depending on the class's method it associated
with. We will learn how to assicate a delegate with a global function or class's
method later.

\textcolor{red}{When a delegate is defined, at runtime, the compiler generates
a class for it}. The generated class has the following properties
\begin{enumerate}
  \item it is a derived class of System::MulticastDelegate, which is a derived
  class of System::Delegate. Both upper classes are defined in System.dll
  
  \item it has three constructors
\begin{verbatim}
  

protected:
    MulticastDelegate();

protected:
    MulticastDelegate(Object^ target, String^ method);

protected:
    MulticastDelegate(Type^ target, String^ method);
\end{verbatim}

An instance of the delegate can thus take two arguments: (1) must be a
pointer to the class that implement the method associated with the delegate, and
(2) must be a reference to the class's method
\begin{verbatim}
using namespace System;

private delegate double Addition();

public ref class CMathOperations
{
public:
    double Plus()
    {
	double a = 248.66, b = 50.28;

	return a + b;
    }
};


int main()
{
    CMathOperations ^ oper = gcnew CMathOperations;
    Addition ^ add = gcnew Addition(oper, &CMathOperations::Plus););
    
    Console::WriteLine(L"Value = {0}", add->Invoke());
    
    return 0;
}
\end{verbatim}
    
    \item it has the method \verb!Invoke()!, with return type and arguments the
    same as the delegate. We use this method to run the delegate (see above).
    

\end{enumerate}
\url{http://www.functionx.com/cppcli/classes/Lesson15c.htm}

Example: In the above example, we use the delegate in the main() function. To
use the delegate in the same class that define the method, the method needs to
be {\bf static}. Here we define a method \verb!ShowResult()! in which it defines
a delegate that use the \verb!Times()! method of the same class. The field data
\verb!multi! is a reference to the delegate \verb!Multiplication!.

\begin{verbatim}
private delegate double Addition();
private delegate double Multiplication();

public ref class CMathOperations
{
private:
    Multiplication ^ multi;
    
public:
    double Plus()
    {
	double a = 248.66, b = 50.28;

	return a + b;
    }

    static double Times()
    {
	double a = 248.66, b = 50.28;

	return a * b;
    }
    
    CMathOperations()
    {
        multi = gcnew Multiplication(&Times);
    }
    
    void ShowResult()
    {
	  Console::WriteLine(L"Multiplication = {0}", multi->Invoke());
    }    
};
\end{verbatim}

Comparison between a delegate and a function pointer
\begin{enumerate}
  \item Similar: (1) it's not a normal function, (2) it has the apperance of a
  variable that is declared as a pointer, (3) it can takes arguments
  \item Difference: [a]	a function pointer can associate with a global function,
  [b] a delegate can ONLY associate with a member of a class
\end{enumerate}
A delegate use some of behind-the-scences template approach to create a
template-class function-pointer-type-thing that works in the way you want. 
 
We need to use C++/CLI program (Sect.\ref{sec:VC++_Windows}), and then the
method of a class use the new extension keyword \verb!delegate! to become a
delegate
\begin{verbatim}
[Access Level] delegate Function-Signature;
\end{verbatim}
with
\begin{itemize}
  \item Access Level (optional): can be {\bf private} or {\bf public}
  \item Function-Signature: just like a normal function, it includes (1) a
  return type (anything), a method name, parentheses, and optional arguments.
  \item End it with a semi-colon (;)
\end{itemize}

More complicated uses of \verb!delegate!:
\url{http://www.functionx.com/cppcli/classes/Lesson15c.htm}	

\subsection{Rule of Three (C++)}

If a class defines one of the following method, it should define all of them
\begin{enumerate}
  \item destructor
  \item constructor
  \item copy assignment operator
\end{enumerate}
This is particularly important if you have a complex data structures or have
external references (e.g. pointers, since only pointers get copy, not the
object it points to).

Example: 
\begin{lstlisting}
class foo_t
{
  friend std::ostream & operator<<( std::ostream & os, foo_t const & foo )
  {
    os << foo.data;
    return os;
  }
  private: 
    char * data;      
  public:
    foo_t( ) : data( new char[ 14 ] ) { std::strcpy( data, "Hello, World!" ); } 
    foo_t( foo_t const & other ) 
    {
      data = new char[ std::strlen( other.data ) + 1 ];
      std::strcpy( data, other.data );
    }
    ~foo_t( ) { delete [] data; }
 
    foo_t& operator= ( foo_t other )
    {
      std::swap(data, other.data);
      return *this;
    }
}
\end{lstlisting}
Defining standard I/O is necessary so that they can be embedeed in
\verb!std::cout! statement.
\begin{lstlisting}
int main( )
{
  foo_t foo;
  std::cout << foo << '\n';
}
\end{lstlisting}


\url{http://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)}

\subsection{RAII (C++)}
\label{sec:RAII}

RAII = Resource Acquisition is Allocation, i.e. the (memory) resource is
initialized in a constructor and discarding it in a destructor, i.e. when the
execution go out of the scope in which the resource is created.

A code comply with this RAII technique will prevent memory leak. This is a
standard in C++; where the only code to be guarantee to be executed after an
exception is thrown are the destructors of the objects residing on stacks.

Example: at the beginning of a function, you allocate 10 blocks of memory, open
  2 files and acquire a lock; if the code run fine, at the end of the file,
  you call the proper functions to free the allocated memory, close the files,
  and release the lock. However, what if exception is raised in the middle of
  the code? To avoid memory leak while
\begin{enumerate}
  \item  controlling \verb!mutex! locks in multi-threaded applications. If the
  code complies with RAII, when the object is destroyed, it must release the lock.
  \item interacting with files. When a file is opened for writing, if the object
  to the file is out of scope, upon the destruction of this object, the file
  must be automatically closed and resource must be released.
  \item memory allocation/deallocation
\end{enumerate}
% 
% C++ provides \verb!std::auto_ptr<>! template
% class, the simplest smart pointer that allows RAII to take place on objects
% stored on the heap or that use file resources.

As there is no such feature in C. To take advantage of RAII, any C code should be
wrapped in C++ classes first. Example: original C
\begin{lstlisting}
{ 
  int device;
  if (...) {
     device = open(...);
  }else{
     device = socket(...);
  }

  ... //potential problem; if exception is raised here or
     //code is returned without closing the device 
    
  close(device);
}
\end{lstlisting}
So, we can define a C++ class that wrap the device ID.
\begin{lstlisting}
struct DeviceCloser {
   int m_device;
   
   DeviceCloser() : m_device=NULL {}
   ~DeviceCloer() { close(m_device)}
}   
\end{lstlisting}
and use
\begin{lstlisting}
{ 
   DeviceCloser dc;
   int &device = dc.m_file;
   
   if (...) {
      device = open(...);
   } else{
      device = socket(...);
   }
   ...
   
   close(device);
}
\end{lstlisting}
Even better with
\begin{lstlisting}
struct DeviceCloser {
   int m_device;
   DeviceCloser (string device_name) {
     if (...) {
        device = open(device_name,...);
     }else{
        device = socket(...);
        ...
     }
   }
   ~DeviceCloser() { close(m_device)}
}

{
  string device_name("PathToFile");
  DeviceCloser dc(device_name);
  
  dc.start();
  
  
  ...
  
}
\end{lstlisting}

\textcolor{red}{GCC comes with some
extension that uses a complex macro; so the code is not portable or doesnot work
with other compilers}. Basically, we define which function to call when one
variable goes out of the scope. We need to use \verb!__attribute__!
keyword, followed by an attribute specification (e.g. \verb!cleanup!) inside a
double parantheses (( \ldots )). The caveat is that it CANNOT be used with
function's parameters or static variables. 

\begin{lstlisting}
#define autofree __attribute__((cleanup(__autofree)))  
\end{lstlisting}
and then 
\begin{lstlisting}
int main(int argc, char **argv) {
  autofree char* x = malloc(20);
  { 
     autofree char* y = malloc(10);
     
  }
  return 0;
}
\end{lstlisting}
Here, when 'x' and 'y' go out of scope, the user-defined cleaner function
\verb!__autofree()! is called
\begin{lstlisting}
 void __autofree(void *p)  
 {  
     void **_p = (void**)p;  
   
     printf("free -> %p\n", *_p);  
     free(*_p);  
 }  
\end{lstlisting}

There are different attributes
\footnote{\url{http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Variable-Attributes.html}};
some are for functions, some are for data-types.

Example: first define the macro that tell vartype, varname, what to do when
init, what to do when destroy
\begin{lstlisting}
#define RAII_VARIABLE(vartype,varname,initval,dtor) \
    void _dtor_ ## varname (vartype * v) { dtor(*v); } \
    vartype varname __attribute__((cleanup(_dtor_ ## varname))) = (initval)
\end{lstlisting}
and then use
\begin{lstlisting}
void example_usage() {
  RAIL_VARIABLE(FILE*, logfile, fopen("logfile.txt", "w+"), fclose)
  
  fputs("hello logfile", logfile);
\end{lstlisting}


\begin{mdframed}
Other object-oriented languages offer garbage-collection that can serve as an
alternative to RAII for 'shallow' resources.
\end{mdframed}

Some basic feature of RAII can also be found in C++98 via \verb!std::auto_ptr<>!
template class (Sect.\ref{sec:auto_ptr}) or in Boost libraries via \verb!boost::shared_ptr!.

To guarantee all of this, C++11 uses smart
pointer classes \verb!std::unique_ptr! (single-owned objects) and \verb!std::shared_ptr!
(objects with shared ownership). These 




References:
\begin{enumerate}
  \item \url{http://smackerelofopinion.blogspot.com/2012/11/using-gcc-cleanup-attribute.html}
  \item
  \url{https://www.ibm.com/developerworks/mydeveloperworks/blogs/karsten/entry/raii_with_c_libraries?lang=enable_if}
  \item \url{http://www.slideshare.net/amdokamal/raii}
\end{enumerate}

\subsection{NUXI problem - little-endian or big-endian byte order}
\label{sec:byte-order}
\label{sec:little-endian}
\label{sec:big-endian}

Microprocessors have data registers. When the data register is 8-bit, or
byte-sized, reading data is convenient. With 16-bit data registers or more, it
has a design issue. When you read a 16-bit value from a byte-addressable data
store, which byte do you load first?
\begin{enumerate}
  \item read the most significant byte first: big-endian (Motorola
  microprocessor, PowerPC)
  
  \item read the least significant byte first: little-endian (Intel
  microprocessors)
\end{enumerate}
The difference between big-endian and little-endian systems is often referred to
as "byte-sex".  

At the O/S level:
\begin{itemize}

  \item  A decision was made VERY long ago that Windows would not be
ported to a big-endian processor. Since almost all the new processors coming out
are either little-endian, or swing both ways (this is true of all the RISC
machines Windows has supported, for example), this isn't really a big deal.

  \item Solaris on SPARC microprocessor: big-endian
\begin{verbatim}
//command (1 = little-endian, 0 = big-endian)
$echo -n I | od -to2 | head -n1 | cut -f2 -d" " | cut -c6 


// python
python -c "import sys;sys.exit(0 if sys.byteorder=='big' else 1)"
\end{verbatim}

  \item Linux on x86 (Intel chip): little-endian
\begin{verbatim}
//command
$lscpu

Byte Order:            Little Endian
\end{verbatim}
\end{itemize}

The real problem starts when binary data gets saved to disk and shared.

UNIX stored data on a big-endian, the lowest address is the biggest-byte. So,
with 4 bytes (U,N,I,X) in that order and want to store as 2 'short' (UN, IX)
\begin{verbatim}
Byte:     U N I X
Location: 0 1 2 3
\end{verbatim}
'U' is the biggest-byte; and thus is stored first.

On little-endian system, the little byte is stored first, so 
\begin{verbatim}
Byte:     N U X I
Location: 0 1 2 3
\end{verbatim}

Also, converting between endians and byte-order reversing are common operations.
A set of functions available on any computer are the htonl(), ntohl(), htons(),
and ntohs() networking functions.  

To extract single-byte, we do
\begin{lstlisting}
unsigned char bytes[4];
int x = 0x0000101D;
bytes[0] = (x >> 24) & 0xFF;
bytes[1] = (x >> 16) & 0xFF;
bytes[2] = (x >>  8) & 0xFF;
bytes[3] =  x        & 0xFF;
\end{lstlisting}

References:
\url{http://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/}

\subsection{Calling conventions}

A very important topics, known as {\bf calling convention} that define how
arguments are passed in a function call. This can be referenced in a Chapter
{\bf X86 and X86-64} in the Fortran-manual book.

\url{http://nondot.org/sabre/LLVMNotes/CustomCallingConventions.txt}


\subsection{C++98-ABI compatibility with C++11}
\label{sec:ABI-compatibility-C++98-C++11}

An introduction to ABI is given in Sect.\ref{sec:ABI}.
C++98 ABI is binary-compatible with C++11. But several places in the library
this is not; mainly related to C++11 standard requiring a different
implementation of C++ string (and list) type(s). 

ERROR when a C++11 compiler try to link the code to a library compiled using
C++98 compiler
\begin{verbatim}
undefined reference to (std::__cxx11::basic_string
\end{verbatim}

EXPLAIN: g++5.2 and above compiles the new C++11 compliant type by default,
(whether or not you specify -std=c++11).
Take home message: when you link together everything must either be the old ABI
or the new ABI.

TO TEST and find out which string ABI is used
\begin{verbatim}
g++ --version
echo '#include <string>' > test.cpp
echo 'void f(std::string s) {}' >> test.cpp
cat test.cpp
g++ -std=gnu++11 -c -o test.o test.cpp
nm test.o | c++filt

/////////// if the result is
std::basic_string<char, .... --> old C++98 string ABI

//////////
std::__cxx11::basic_string<char, ... --> C++11 ABI
\end{verbatim}

SOLUTION:
\begin{enumerate}
  \item  If you have the code for the library, it's best to recompile using the
  new compiler. 

By default since gcc 5.2, C++11 new ABI is used. To enforce using it, add the
macro to compiler option
\begin{verbatim}
-D_GLIBCXX_USE_CXX11_ABI=1
\end{verbatim}
Another way is to add the macro to all or the files that uses std::string
\begin{verbatim}
#define _GLIBCXX_USE_CXX11_ABI 0/1
\end{verbatim}

  %Otherwise, follow the links to know how to fix it.
  \item For compatibility, you can set the macro
\begin{verbatim}
-D_GLIBCXX_USE_CXX11_ABI=0
\end{verbatim}
to the C++11 compiler to revert to the old C++ string type.

NOTE: New libstdc++ implementation contain both ABIs. So if you have binaries
you have to link against with the old non-compliant ABI, you must set the macro
above on your g++ compiles. This should produce binaries compatible with the old
ABI.   

Unfortunately if you are using libraries from the OS other than the C++ Standard
Libraries, then unless these libraries are multi-arch in the sense of
providing all functions which differ by ABI in both ABI's, then you're screwed
because they'll probably only have the new ABI.  

\end{enumerate}


References:
\begin{enumerate}
  \item \url{http://gcc.gnu.org/wiki/Cxx11AbiCompatibility}
  \item
  \url{https://askubuntu.com/questions/770358/how-should-i-handle-abi-incompatability-between-gcc-4-9-and-gcc-5}
\end{enumerate}

\subsection{Invalid conversion from void* to \ldots}

In C++, we should use explicit type-case to avoid errors like
\begin{verbatim}
invalid conversion from void* to char*
invalid conversion from void* to OBJECT*
\end{verbatim}

Example:
\begin{verbatim}
void foo (void* arr) {
  if (something) {
     char * ptr;  
     ptr = (char*) arr;  //
  }else {
     int * ptr;  
     ptr = (int*) arr;  //
  
  }
}
\end{verbatim}

\subsection{Incomplete last line}


These are the error messages you may get
\begin{verbatim}
No new line at end of file

\ No newline at end of file
\end{verbatim}

A text file in Unix has multiple lines, each ends with a newline character
(\verb!\n!). [NOTE: The newline character in Windows is CR LF sequence
(\verb!\r\n!)] A file that is not empty and doesnot end with a newlie is
therefore not a text file. Traditionally, GNU utilities may not work properly with these non-text files.

Utilities that works on per-line unit needs to know the starts and ends of each
line. In utilities like \verb!diff, sdiff!, it carefully note that fact if one
of the line not ending with a newline character. 

If you don't have the newline in the last line of a file, unexpected behavior
may occur when you try to combine that file with another one, in that the first
line in the second file is merged with the last line in the first one into a
single line. This is the case when you try to use \verb!#include! command to
include the header file into the source file. Since C++11 standard, the
requirement for every source file with a non-escaped newline was removed. In
other words, the compiler that support C++11 should be able to detect and not
producing the warning when compiling C++11 codes
\begin{verbatim}
A source file that is not empty and that does not end in a new-line character,
or that ends in a new-line character immediately preceded by a backslash
character before any such splicing takes place, shall be processed as if an
additional new-line character were appended to the file (C++11 2.2/1)  
\end{verbatim}

\url{http://stackoverflow.com/questions/72271/no-newline-at-end-of-file-compiler-warnings}

\subsection{Generic programming}


\subsection{mmap()}
\label{sec:mmap}


The only similarity between \verb!mmap()! and \verb!malloc()! is that they both
return a pointer to the data we want to access. But \verb!mmap()! returns the
pointer to memory on disk, while \verb!malloc()! returns the pointer to memory
on heap (in the RAM). 

\verb!mmap()! doesn't allocate memory, it just does memory-mapping, i.e. the
data is not loaded into RAM; but instead provides a tool that allows a process
to access data from the disk directly. There are two main usages:
\begin{enumerate}
  \item reduce the RAM usage, i.e. when the file is too big to fit into the RAM
  memory and very large data can be handled efficiently.
  \item two or more separate program can access the data from the same file,
  reducing the redundant RAM usage.
\end{enumerate}
Of course, accessing data on disk is slower than on RAM. In a 64-bit system,
\verb!mmap()! can address any location on the disk, while in a 32-bit system, it
can only access the first 4GB.


To find out which file/directory is openned by a process, we can use
\begin{itemize}
  \item in Windows: Process Explorer
  \url{http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx}
\end{itemize}

\subsection{SFINAE}
\label{sec:SFINAE}

SFINAE was initially introduced to avoid creating ill-formed programs when unrelated template declarations were visible.

SFINAE states that failing to instantiate a template with some particular
template arguments does not result in an error and simply discards that
instantiation. 

Recently, it allows a template to determine certain properties of its template arguments at instantiation time.
SFINAE can be used to determine if a type contains a certain typedef, e.g. Sect.\ref{sec:SFINAE-C++11}.

